{"changed":true,"filter":false,"title":"grammar.js","tooltip":"/src/data/grammar.js","value":"\ndefine(['../utils/obj'],  function(k)\n{\n\t'use strict';\n\n\t/**\n\t* Enum for any special Symbol\n\t* @readonly\n\t* @enum {String}\n\t*/\n    var specialSymbol = {\n        EMPTY: 'EMPTY',\n        EOF : 'EOF'\n    };\n\n     /** Symbol\n    * @class\n    * @classdesc This class represent any simbol in the entire system */\n    var Symbol = (function ()\n    {\n        /*\n        * Creates an instance of a Symbol (This class represent non Temrinals, Terminals and Special symbols)\n        *\n        * @constructor\n        * @param {String} options.name The name or denatation of the non terminal\n        * @param {Boolean} options.isSpecial Determiens if the current symbol is a secial one, like EOF. Default false\n        */\n        var symbol = function (options)\n        {\n\t\t\tthis.options = options;\n\n\t\t\tk.utils.obj.defineProperty(this, 'name');\n\t\t\tk.utils.obj.defineProperty(this, 'isSpecial');\n\n            this.isSpecial = !!options.isSpecial;\n\n            if (!this.name || !k.utils.obj.isString(this.name))\n            {\n                throw new Error('Invalid initialization values for a symbol, please provide a string name a symbol');\n            }\n        };\n\n        /** @function Shows the symbol's name\n        * @returns this.name */\n        symbol.prototype.toString = function() {\n            return this.name.toString();\n        };\n\n        /* @function Creates a deep copy of the current instance\n        * @returns Deep copy */\n        symbol.prototype.clone = function() {\n\t\t\treturn new Symbol(k.utils.obj.clone(this.options));\n        };\n\n        return symbol;\n    })();\n\n    /** Non Terminal\n    * @class\n    * @classdesc Use this class to create new instance of non Termianls */\n    var NonTerminal = (function(_super)\n    {\n        /* jshint latedef:false */\n        k.utils.obj.inherit(nonTerminal, _super);\n        /*\n        * Creates an instance of a new Non Termianl\n        *\n        * @constructor\n        * @param {String} options.name The name or denatation of the non terminal\n        */\n        function nonTerminal (options)\n        {\n            _super.apply(this, arguments);\n        }\n\n        /** @function Creates an array os non terminals from a string that represen them\n         * @param {[Array]} arr Array of string used to create new non terminals\n         * @returns An array of new nonterminals  */\n        nonTerminal.fromArray = function (arr)\n        {\n            if (!k.utils.obj.isArray(arr) && !k.utils.obj.isString(arr)) {\n                throw new Error('Invalid parameter. To create non terminal from array the input parameter should be an array!');\n            }\n            var result = [];\n            for (var i = 0; i < arr.length; i++)\n            {\n                result[i] = new NonTerminal({\n                    name: arr[i]\n                });\n            }\n\n            return result;\n        };\n\n        /* @function Creates a deep copy of the current instance\n        * @returns Deep copy */\n        nonTerminal.prototype.clone = function() {\n\t\t\treturn new NonTerminal(k.utils.obj.clone(this.options));\n        };\n\n        return nonTerminal;\n    })(Symbol);\n\n\t/** Terminal\n    * @class\n    * @classdesc Use this class to repsent Termianls (like 'a', 'B', 'Hola', etc.) */\n    var Terminal = (function(_super)\n    {\n        /* jshint latedef:false */\n        k.utils.obj.inherit(terminal, _super);\n        /*\n        * Creates an instance of a new Termianl\n        *\n        * @constructor\n        * @param {String} options.name The name or denatation of the terminal\n        * @param {String|RegExp} options.body The string or regexp used to match the input tokens\n        */\n        function terminal (options)\n        {\n            if (!k.utils.obj.isString(options.body) && !k.utils.obj.isRegExp(options.body)) {\n                throw new Error('Invalid Terminal Initialization. A string or regexp body must be specified');\n            }\n\t\t\toptions.name = options.name ? options.name : options.body.toString();\n\n            _super.apply(this, arguments);\n\n            k.utils.obj.defineProperty(this, 'body');\n            k.utils.obj.defineProperty(this, 'isTerminal');\n\n            this.isTerminal = true;\n        }\n\n        /* @function Shows the terminal's name between < and >\n        * @returns Fromatted string */\n        terminal.prototype.toString = function() {\n            return '<' + this.name + '>';\n        };\n\n\t\t/* @function Creates a deep copy of the current instance\n        * @returns Deep copy */\n        terminal.prototype.clone = function() {\n\t\t\tvar cloneOptions = k.utils.obj.clone(this.options);\n\t\t\tcloneOptions.body = k.utils.obj.isRegExp(this.body) ? new RegExp(this.body.source) : this.body;\n\n\t\t\treturn new Terminal(cloneOptions);\n        };\n\n        return terminal;\n    })(Symbol);\n\n     /**  Grammatical Rules\n    * @class\n    * @classdesc Use this class to create new instance of non Termianls */\n    var Rule = (function()\n    {\n         /*\n        * Initialize a new Grammatical Rule\n        *\n        * @constructor\n        * @param {nonTerminal} options.head The name or denatation of the non terminal\n        * @param {[terminal|nonTerminal]} [options.tail] Array of terminals and nonTerminals that represent the tail of the rule. If is not present an empty tail will be created.\n        */\n        var rule = function (options)\n        {\n            this.index = -1;\n            this.options = options;\n\n            if (!options.head)\n            {\n                throw new Error('Invalid initialization values, please provide a head for the rule');\n            }\n\n\t\t\t//Define alias for:\n            k.utils.obj.defineProperty(this, 'head');\n            k.utils.obj.defineProperty(this, 'tail');\n\n            this.head = !(options.head instanceof NonTerminal) ?\n\t\t\t\tnew NonTerminal({\n\t\t\t\t\tname: options.head.toString()\n\t\t\t\t}) :\n\t\t\t\toptions.head;\n\n\t\t\tthis.tail = (options.tail && k.utils.obj.isArray(options.tail)) ? options.tail : [new Symbol({name: specialSymbol.EMPTY, isSpecial: true})];\n        };\n\n        /* @function Convert a Rule to its pritty string representation\n        * @returns Formatted string */\n        rule.prototype.toString = function()\n        {\n            return this.head.toString() + '-->' + this.tail.join(' ');\n        };\n\n        /* @function Clone the current item, generating a deep copy of it.\n        * @param {Boolean} options.copyRuleIndex Indicate if the index should be copied or not. Default: false\n        * @returns A deep copy of the current item */\n        rule.prototype.clone = function(options)\n        {\n\t\t\tvar cloneOptions = k.utils.obj.clone(this.options);\n\n\t\t\tcloneOptions.head = this.head.clone();\n\t\t\tcloneOptions.tail = k.utils.obj.map(this.tail, function(symbol) {\n\t\t\t\treturn symbol.clone();\n\t\t\t});\n\n\t\t\tvar result = new Rule(cloneOptions);\n\n\t\t\tif (options && options.copyRuleIndex)\n\t\t\t{\n\t\t\t\tresult.index = this.index;\n\t\t\t}\n\n\t\t\treturn result;\n        };\n\n        return rule;\n    })();\n\n     /**  Grammar\n    * @class\n    * @classdesc This class is used to represent grammars */\n    var Grammar = (function ()\n    {\n        var defaultOptions = {\n            name: ''\n        };\n\n        /*\n        * Initialize a new Grammar\n        *\n        * @constructor\n        * @param {NonTerminal} options.startSymbol Start symbol of the grammar\n        * @param {[Rule]} options.rules Array of grammatical rules\n        */\n        var grammar = function (options)\n        {\n            this.options = k.utils.obj.extendInNew(defaultOptions, options || {});\n\n\t\t\t//Define alias for:\n            k.utils.obj.defineProperty(this, 'startSymbol');\n            k.utils.obj.defineProperty(this, 'rules');\n\n            this.rulesByHeader = this._getIndexByNonTerminals(this.rules);\n            this.terminals = this._getTerminals(this.rules);\n        };\n\n        /* @function Index all grammatical rules by its header non terminal\n        * @param {[rule]} rules Array grammatical rules of the current grammar\n        * @returns An object that has an array of rules per each non terminal name property  */\n        grammar.prototype._getIndexByNonTerminals = function(rules)\n        {\n            var result = {};\n            for (var i = 0; i < rules.length; i++)\n            {\n\t\t\t\trules[i].index = i;\n\t\t\t\t/* jshint expr:true */\n                result[rules[i].head.name] ? result[rules[i].head.name].push(rules[i]) : result[rules[i].head.name] = new Array(rules[i]);\n            }\n            return result;\n        };\n\n         /* @function Compute an Array of all grammar's terminals'\n         * @param {[rule]} rules Array grammatical rules of the current grammar\n         * @returns An ordered array of object containg the terminals and the rules that define them */\n        grammar.prototype._getTerminals = function(rules)\n        {\n            var result = [];\n            for (var i = 0; i < rules.length; i++)\n            {\n                if (rules[i].tail.length === 1 && rules[i].tail[0].isTerminal)\n                {\n                    result[result.length] = {\n                        body: rules[i].tail[0].body,\n                        rule: rules[i]\n                    };\n                }\n            }\n            return result;\n        };\n\n         /** @function Returns the list of rules that start with the specified symbols as the head\n         * @param {Symbol} symbol Symbol used as the head of the requested rules\n         * @returns Array of rules */\n        grammar.prototype.getRulesFromNonTerminal = function(symbol)\n        {\n            return this.rulesByHeader[symbol.name];\n        };\n\n        /** @function Convert a Grammar to its pritty string representation\n        * @returns Formatted string */\n        grammar.prototype.toString = function() {\n            var strResult = this.name ? 'Name: ' + this.name : '';\n            strResult += 'Start Symbol: ' + this.startSymbol.name +'\\n';\n\n            for (var i = 0; i < this.rules.length; i++) {\n                strResult += i +': '+ this.rules[i] + '\\n';\n            }\n            return strResult;\n        };\n\n        return grammar;\n    })();\n\n    k.data = k.utils.obj.extend(k.data || {}, {\n        Symbol: Symbol,\n        NonTerminal: NonTerminal,\n        Terminal: Terminal,\n        Rule: Rule,\n        Grammar: Grammar,\n        specialSymbol: specialSymbol\n    });\n\n    return k;\n});","undoManager":{"mark":-1,"position":0,"stack":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":1,"column":0}},"text":"\n"}]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":5,"column":0},"end":{"row":5,"column":0},"isBackwards":false},"options":{"tabSize":4,"useSoftTabs":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":false}