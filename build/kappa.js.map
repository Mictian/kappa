{"version":3,"sources":["__prologue__.js","obj.js","str.js","node.js","grammar.js","astNode.js","itemRule.js","stackItem.js","state.js","automata.js","lexer.js","automataLRGeneratorBase.js","automataLR0Generator.js","automataLALR1Generator.js","conflictResolver.js","parser.js","__epilogue__.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5OA;AACA;AACA","file":"kappa.js","sourcesContent":["/** Package wrapper and layout.\n*/\n\"use strict\";\n(function (global, init) { // Universal Module Definition.\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine([/* Put dependencies here. */], init); // AMD module.\n\t} else if (typeof module === 'object' && module.exports) {\n\t\tmodule.exports = init(/* require(\"dep'), ... */ ); // CommonJS module.\n\t} else { // Browser or web worker (probably).\n\t\tglobal.kappa = init(/* global.dep, ... */); // Assumes base is loaded.\n\t}\n})(this, function __init__() {\n\n\tvar k = { // Library layout. ///////////////////////////////////////////////\n\t\t__name__: 'kappa',\n\t\t__init__: __init__,\n\t\t__dependencies__: { /* 'dep': dep, ... */ },\n\t\t__version__: '0.0.1',\n\t// Namespaces.\n\t\tutils: {},\n\t\tdata: {},\n\t\tlexer: {},\n\t\tparser: {},\n\t};\n\n// Continued by all sources concatenated and __epilogue__.js at the end.","\nk.utils.obj = (function ()\n{\n\t'use strict';\n\t/*\n\t* @func Util function used to apply \"Inheritance\"\n\t*\n\t* @param {Object} superType Object to inherit from\n\t* @param {Object} subType Enhanced Object\n\t* @returns void\n\t*/\n\tvar __inherit = function (subType, superType)\n\t{\n\t\tfor (var p in superType) {\n\t\t\tif (superType.hasOwnProperty(p)) {\n\t\t\t\tsubType[p] = superType[p];\n\t\t\t}\n\t\t}\n\n\t\tfunction __() {\n\t\t\tthis.constructor = subType;\n\t\t}\n\t\t__.prototype = superType.prototype;\n\t\t/* jshint newcap:false */\n\t\tsubType.prototype = new __();\n\t};\n\n\t/*\n\t* @func Util function used to define properties in objects, Common to define alias, insteas od using instance.options.property, used instance.property\n\t* It is VERY IMPORTANT to notice that all propoerties are set and get from a property called options in the context object, unless getter and setter functions are specified\n\t*\n\t* @param {Object} ctx Object containing the options. Father object\n\t* @param {String} propName Name of the property to add/alias\n\t* @param {Function} options.set Optional function used ot override the default getter\n\t* @param {Function} options.get Optional function used ot override the default setter\n\t* @returns void\n\t*/\n\tvar __defineProperty = function(ctx, propName, options)\n\t{\n\t\tif (!ctx || !propName)\n\t\t{\n\t\t\tthrow new Error('Invalid property specification. In order to create a property please specify a context and a property name.');\n\t\t}\n\n\t\tvar propertyOptions = __extend({\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\t'set': function (val) {\n\t\t\t\tctx.options[propName] = val;\n\t\t\t},\n\t\t\t'get': function () {\n\t\t\t\treturn ctx.options[propName];\n\t\t\t}\n\t\t}, options || {});\n\n\t\tObject.defineProperty(ctx, propName, propertyOptions);\n\t};\n\n\t/*\n\t* @func Util function to extend an object. This function accepts n arguments and the first one will be the same as the retuned one (the extended)\n\t* @param {Object} obj object to extend form\n\t* @returns {Object} The initial object with the added properties form next arguments\n\t*/\n\tvar __extend = function(obj)\n\t{\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tif (args[i]) {\n\t\t\t\tfor (var prop in args[i]) {\n\t\t\t\t\tobj[prop] = args[i][prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t};\n\n\t/*\n\t* @func Util function to clone OBJECTS by using JSON.parser/stringify (a deep clone)\n\t* @param {Object} obj object to clone\n\t* @returns {Object} A copy of the passed in object\n\t*/\n\tvar __clone = function(obj)\n\t{\n\t\treturn JSON.parse(JSON.stringify(obj));\n\t};\n\n\t/*\n\t* @func Util function to extend an object. This function accepts n arguments and the first one will be the same as the retuned one (the extended)\n\t* @param {Object} obj object to extend form\n\t* @returns {Object} A new object with the added properties form next arguments\n\t*/\n\tvar __extendInNew = function(obj)\n\t{\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\n\t\t\tresOjb = __clone(obj);\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tif (args[i]) {\n\t\t\t\tfor (var prop in args[i]) {\n\t\t\t\t\tresOjb[prop] = args[i][prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn resOjb;\n\t};\n\n\t/*\n\t* @func Util function to determine if an object is or not an array\n\t* @param {Object} o object to check its type\n\t* @returns {Boolean} True if the object passed in is an Array or false otherwise\n\t*/\n\tvar __isArray = function(o)\n\t{\n\t\treturn Object.prototype.toString.call(o) === '[object Array]';\n\t};\n\n\t/*\n\t* @func Util function to determine if an object is or not a String\n\t* @param {Object} s object to check its type\n\t* @returns {Boolean} True if the object passed in is a String or false otherwise\n\t*/\n\tvar __isString = function(s)\n\t{\n\t\treturn Object.prototype.toString.call(s) === '[object String]';\n\t};\n\n\t/*\n\t* @func Util function to determine if an object is or not a Regular Expression\n\t* @param {Object} s object to check its type\n\t* @returns {Boolean} True if the object passed in is a Regular Expresion, false otherwise\n\t*/\n\tvar __isRegExp = function(r)\n\t{\n\t\treturn Object.prototype.toString.call(r) === '[object RegExp]';\n\t};\n\n\t/*\n\t* @func Util function to determine if an object is or not a Number\n\t* @param {Object} n object to check its type\n\t* @returns {Boolean} True if the object passed in is a Number, false otherwise\n\t*/\n\tvar __isNumber = function(n)\n\t{\n\t\treturn Object.prototype.toString.call(n) === '[object Number]';\n\t};\n\n\t/*\n\t* @func Util function to determine if an object is or not a Function\n\t* @param {Object} f object to check its type\n\t* @returns {Boolean} True if the object passed in is a Function, false otherwise\n\t*/\n\tvar __isFunction = function(f)\n\t{\n\t\treturn Object.prototype.toString.call(f) === '[object Function]';\n\t};\n\n\t/*\n\t* @func Util function to determine if an object is or not Boolean\n\t* @param {Object} b object to check its type\n\t* @returns {Boolean} True if the object passed in is Boolean, false otherwise\n\t*/\n\tvar __isBoolean = function(b) {\n\t\treturn b === true || b === false || Object.prototype.toString.call(b) === '[object Boolean]';\n\t};\n\n\t/*\n\t* @func Util function to determine if an object is the JS Arguments array, which is of a particular type\n\t* @param {Object} a object to check its type\n\t* @returns {Boolean} True if the object passed in is an Arguments Array, false otherwise\n\t*/\n\tvar __isArguments = function(a)\n\t{\n\t\treturn Object.prototype.toString.call(a) === '[object Arguments]';\n\t};\n\n\tif (!__isArguments(arguments)) {\n\t\t__isArguments = function(a) {\n\t\t\treturn !!(a && __has(a, 'callee'));\n\t\t};\n\t}\n\n\t/*\n\t* @func Util function to determine if an thing is or not a Object\n\t* @param {Thing} n object to check its type\n\t* @returns {Boolean} True if the thing passed in is a Object, false otherwise\n\t*/\n\tvar __isObject = function(obj) {\n\t\treturn obj === Object(obj) && !__isFunction(obj);\n\t};\n\n\t/*\n\t* @func Util function to determine if a thing is or not defined\n\t* @param {Thing} obj object to check its state\n\t* @returns {Boolean} True if the thing passed in is Undefined, false otherwise\n\t*/\n\tvar __isUndefined = function(obj) {\n\t\treturn obj === void 0;\n\t};\n\n\t/*\n\t====================================================================================================================================\n\tThe next function are copied from underscorejs.org. These function are here because I want to be in control of all the code I manage.\n\tBesides I like that I my code pass my JSHint rule, which are much more stringer that the onces applied by underscore.js\n\t*/\n\n\t/*General Variables*/\n\tvar breaker = {};\n\tvar ArrayProto\t= Array.prototype,\n\t\tconcat\t\t= ArrayProto.concat,\n\t\tpush\t\t= ArrayProto.push,\n\t\tFuncProto\t= Function.prototype;\n\n\tvar nativeKeys         \t= Object.keys,\n\t\tnativeForEach      \t= ArrayProto.forEach,\n\t\tnativeReduce       \t= ArrayProto.reduce,\n\t\tnativeBind         \t= FuncProto.bind,\n\t\tnativeFilter    \t= ArrayProto.filter,\n\t\tnativeSome\t\t\t= ArrayProto.some,\n\t\tnativeEvery\t\t\t= ArrayProto.every,\n\t\tnativeIndexOf\t\t= ArrayProto.indexOf,\n\t\tslice\t\t\t\t= ArrayProto.slice;\n\n\t/* @func Alias of hasOwnProperty just for brevety\n\t* @param {Object} obj object to check ownership of property\n\t* @param {String} key Property name to verify\n\t* @returns {Boolean} True if the object posses that property\n\t*/\n\tvar __has = function(obj, key) {\n\t\treturn hasOwnProperty.call(obj, key);\n\t};\n\n\t/* @func Returns the list of own properties of an object\n\t* @param {Object} obj object from which extract keys\n\t* @returns {Array} List of string keys of property names of the object passed in\n\t*/\n\tvar __keys = function(obj) {\n\t\tif (!__isObject(obj))\n\t\t{\n\t\t\treturn [];\n\t\t}\n\t\tif (nativeKeys)\n\t\t{\n\t\t\treturn nativeKeys(obj);\n\t\t}\n\t\tvar keys = [];\n\t\tfor (var key in obj){\n\t\t\tif (__has(obj, key))\n\t\t\t{\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\t\treturn keys;\n\t};\n\n\t/* @func Iterate over the passed in first parameter calling the iterator with the specified context\n\t* @param {Object} obj object to traverse\n\t* @param {Function} iterator function called per each item founded in obj\n\t* @param {Object} context object from which extract keys\n\t* @returns {Array} List of string keys of property names of the object passed in\n\t*/\n\tvar __each = function(obj, iterator, context) {\n\t\tif (obj === null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\tvar i,\n\t\t\tlength;\n\t\tif (nativeForEach && obj.forEach === nativeForEach)\n\t\t{\n\t\t\tobj.forEach(iterator, context);\n\t\t}\n\t\telse if (obj.length === +obj.length)\n\t\t{\n\t\t\tfor (i = 0, length = obj.length; i < length; i++)\n\t\t\t{\n\t\t\t\tif (iterator.call(context, obj[i], i, obj) === breaker) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar keys = __keys(obj);\n\t\t\tfor (i = 0, length = keys.length; i < length; i++)\n\t\t\t{\n\t\t\t\tif (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t};\n\n\t/* @func Iterate over the passed in first parameter and mapping each of its valur according the iteration logic\n\t* @param {Object} obj object to traverse\n\t* @param {Function} iterator function called per each item founded in obj\n\t* @param {Object} context object from which extract keys\n\t* @returns {Array} List of string keys of property names of the object passed in\n\t*/\n\tvar __map =  function(obj, iterator, context) {\n\t\tvar results = [];\n\t\tif (obj === null)\n\t\t{\n\t\t\treturn results;\n\t\t}\n\t\t__each(obj, function(value, index, list) {\n\t\t\tresults.push(iterator.call(context, value, index, list));\n\t\t});\n\t\treturn results;\n\t};\n\n\tvar reduceError = 'Reduce of empty array with no initial value';\n\n\t/* @func Iterate over the passed in first parameter and group them all into the result by applying the iteralot logic\n\t* @param {Object} obj object to traverse\n\t* @param {Function} iterator function called per each item founded in obj\n\t* @param {Object} memo is the initial state of the reduction\n\t* @param {Object} context object used to call the iterator\n\t* @returns {Array} List of string keys of property names of the object passed in\n\t*/\n\tvar __reduce = function(obj, iterator, memo, context) {\n\t\tvar initial = arguments.length > 2;\n\t\tif (obj === null) {\n\t\t\tobj = [];\n\t\t}\n\t\tif (nativeReduce && obj.reduce === nativeReduce)\n\t\t{\n\t\t\tif (context)\n\t\t\t{\n\t\t\t\titerator = __bind(iterator, context);\n\t\t\t}\n\t\t\treturn initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n\t\t}\n\t\t__each(obj, function(value, index, list) {\n\t\t\tif (!initial) {\n\t\t\t\tmemo = value;\n\t\t\t\tinitial = true;\n\t\t\t} else {\n\t\t\t\tmemo = iterator.call(context, memo, value, index, list);\n\t\t\t}\n\t\t});\n\t\tif (!initial) {\n\t\t\tthrow new TypeError(reduceError);\n\t\t}\n\t\treturn memo;\n\t};\n\n\tvar Ctor = function(){};\n\n\t/* @func Bind a function to an object, meaning that whenever the function is called, the value of this will be the object.\n\t* Optionally, pass arguments to the function to pre-fill them, also known as partial application\n\t* @param {Function} func Function to wrap up\n\t* @param {Object} context Object used as a context in the execution of func\n\t* @returns {Function} A new wrap function\n\t*/\n\tvar __bind = function(func, context) {\n\t\tvar args, bound;\n\t\tif (nativeBind && func.bind === nativeBind) {\n\t\t\treturn nativeBind.apply(func, slice.call(arguments, 1));\n\t\t}\n\t\tif (!__isFunction(func)) {\n\t\t\tthrow new TypeError();\n\t\t}\n\t\targs = slice.call(arguments, 2);\n\t\tbound = function() {\n\t\t\tif (!(this instanceof bound)) {\n\t\t\t\treturn func.apply(context, args.concat(slice.call(arguments)));\n\t\t\t}\n\t\t\tCtor.prototype = func.prototype;\n\t\t\tvar self = new Ctor();\n\t\t\tCtor.prototype = null;\n\t\t\tvar result = func.apply(self, args.concat(slice.call(arguments)));\n\t\t\tif (Object(result) === result)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn self;\n\t\t};\n\t\treturn bound;\n\t};\n\n\t/* @func Iterate over the passed in first parameter and filter them based on the result of the predicate parameter\n\t* @param {Object} obj object to traverse\n\t* @param {Function} predicate function called per each item founded in obj to determine if the item is or no in the final result\n\t* @param {Object} context object used to call the iterator\n\t* @returns {Array} List of item in object that return thruly tp the passed in predicate\n\t*/\n\tvar __filter = function(obj, predicate, context) {\n\t\tvar results = [];\n\t\tif (obj === null) {\n\t\t\treturn results;\n\t\t}\n\t\tif (nativeFilter && obj.filter === nativeFilter) {\n\t\t\treturn obj.filter(predicate, context);\n\t\t}\n\n\t\t__each(obj, function(value, index, list) {\n\t\t\tif (predicate.call(context, value, index, list))\n\t\t\t{\n\t\t\t\tresults.push(value);\n\t\t\t}\n\t\t});\n\t\treturn results;\n\t};\n\n\t/* @func Keep the identity function around for default iterators.\n\t* @param {Object} value Value that will returned\n\t* @returns {Object} The same value that passed in\n\t*/\n\tvar __identity = function(value) {\n\t\treturn value;\n\t};\n\n\t/* @func Determine if at least one element in the object matches a truth test\n\t* @param {Object} obj object to traverse\n\t* @param {Function} predicate function called per each item founded in obj to determine if the item fullfil the requirements\n\t* @param {Object} context object used to call the iterator\n\t* @returns {Boolean} True if at least one item pass the predicate, false otherwise\n\t*/\n\tvar __any = function(obj, predicate, context) {\n\t\tpredicate = predicate || __identity;\n\t\tvar result = false;\n\t\tif (obj === null) {\n\t\t\treturn result;\n\t\t}\n\t\tif (nativeSome && obj.some === nativeSome) {\n\t\t\treturn obj.some(predicate, context);\n\t\t}\n\n\t\t__each(obj, function(value, index, list) {\n\t\t\tif (result || (result = predicate.call(context, value, index, list))) {\n\t\t\t\treturn breaker;\n\t\t\t}\n\t\t});\n\t\treturn !!result;\n\t};\n\n\t/* @func Convenience version of a common use case of map: fetching a property.\n\t* @param {Object} obj Object to be traverse\n\t* @param {String} key Name of the property to extract from eacj item in obje\n\t* @returns {Array} List of each property value from each item in obj\n\t*/\n\tvar __pluck = function(obj, key) {\n\t\treturn __map(obj, __property(key));\n\t};\n\n\t/* @func Auxiliar and Internal function used to return an object's propert by settings using a closure the property name.\n\t* Returns a function that will itself return the key property of any passed-in object\n\t* @param {String} key Name of the property name to 'lock'\n\t* @returns {Function} A function that accepts an object and returns the value of its property set before\n\t*/\n\tvar __property = function(key) {\n\t\treturn function(obj) {\n\t\t\treturn obj[key];\n\t\t};\n\t};\n\n\t/* @func An internal function to generate lookup iterators\n\t* @param {Object} value Lookup\n\t* @returns {Object} Object lookup\n\t*/\n\tvar lookupIterator = function(value) {\n\t\tif (value === null || value === undefined) {\n\t\t\treturn __identity;\n\t\t}\n\t\tif (__isFunction(value)) {\n\t\t\treturn value;\n\t\t}\n\t\treturn __property(value);\n\t};\n\n\t/* @func Sort the object’s values by a criterion produced by an iterator.\n\t* @param {Object} obj object to traverse\n\t* @param {Function} iterator function called per each item founded in obj. Called with value, index, list\n\t* @param {Object} context object from which extract keys\n\t* @returns {Object} The same obj passed in but sorted as specified by the iterator function\n\t*/\n\tvar __sortBy = function(obj, iterator, context) {\n\t\titerator = lookupIterator(iterator);\n\n\t\treturn __pluck(__map(obj, function(value, index, list)\n\t\t{\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tindex: index,\n\t\t\t\tcriteria: iterator.call(context, value, index, list)\n\t\t\t};\n\t\t}).sort(function(left, right) {\n\t\t\tvar a = left.criteria;\n\t\t\tvar b = right.criteria;\n\t\t\tif (a !== b) {\n\t\t\t\tif (a > b || a === void 0) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (a < b || b === void 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn left.index - right.index;\n\t\t}), 'value');\n\t};\n\n\t/* @func Return the first value which passes a truth test\n\t* @param {Object} obj object to traverse\n\t* @param {Function} predicate function called per each item founded in obj\n\t* @param {Object} context object from which extract keys\n\t* @returns {Object} The first item in obj that returns true\n\t*/\n\tvar __find = function(obj, predicate, context) {\n\t\tvar result;\n\t\t__any(obj, function(value, index, list) {\n\t\t\tif (predicate.call(context, value, index, list)) {\n\t\t\t\tresult = value;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t};\n\n\t/* @func An internal function used for aggregate “group by” operations.\n\t* @param {Array} obj object to traverse\n\t* @param {Function} iterator function called per each item founded in obj\n\t* @param {Object} context object from which extract keys\n\t* @returns {Object} Object where each property is the key of each group, and where the values of these key are the array of values grouped\n\t*/\n\tvar group = function(behavior) {\n\t\treturn function(obj, iterator, context) {\n\t\t\tvar result = {};\n\t\t\titerator = lookupIterator(iterator);\n\t\t\t__each(obj, function(value, index) {\n\t\t\t\tvar key = iterator.call(context, value, index, obj);\n\t\t\t\tbehavior(result, key, value);\n\t\t\t});\n\t\t\treturn result;\n\t\t};\n\t};\n\n\t/* @func Determine whether all of the elements match a truth test.\n\t* @param {Array} obj object to traverse\n\t* @param {Function} predicate function called per each item founded in obj to determine if fulfill the requirements\n\t* @param {Object} context object from which extract keys\n\t* @returns {Boolean} Returns true if all of the values in the list pass the predicate truth test.\n\t*/\n\tvar __every = function(obj, predicate, context) {\n\t\tpredicate = predicate || __identity;\n\t\tvar result = true;\n\t\tif (obj === null) {\n\t\t\treturn result;\n\t\t}\n\t\tif (nativeEvery && obj.every === nativeEvery) {\n\t\t\treturn obj.every(predicate, context);\n\t\t}\n\t\t__each(obj, function(value, index, list) {\n\t\t\tif (!(result = result && predicate.call(context, value, index, list)))\n\t\t\t{\n\t\t\t\treturn breaker;\n\t\t\t}\n\t\t});\n\t\treturn !!result;\n\t};\n\n\t/* @func Internal implementation of a recursive flatten function.\n\t* @param {Array} input object to traverse\n\t* @param {Boolean} shallow Indicate if the flattening should NOT be made recusrively (true: DO NOT make it recursively)\n\t* @param {Array} output Output parameter wheere the final list is saved\n\t* @returns {Array} Array where each item if flattened\n\t*/\n\tvar flatten = function(input, shallow, output) {\n\t\tif (shallow && __every(input, __isArray)) {\n\t\t\treturn concat.apply(output, input);\n\t\t}\n\t\t__each(input, function(value) {\n\t\t\tif (__isArray(value) || __isArguments(value)) {\n\t\t\t\tif (shallow) {\n\t\t\t\t\tpush.apply(output, value);\n\t\t\t\t} else {\n\t\t\t\t\tflatten(value, shallow, output);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t});\n\t\treturn output;\n\t};\n\n\t/* @func Flatten out an array, either recursively (by default), or just one level.\n\t* @param {Array} array object to traverse\n\t* @param {Boolean} shallow Indicate if the flattening should NOT be made recusrively (true: DO NOT make it recursively)\n\t* @returns {Array} Array where each item if flattened\n\t*/\n\tvar __flatten = function(array, shallow) {\n\t\treturn flatten(array, shallow, []);\n\t};\n\n\t/* @func Determine if the array or object contains a given value (using ===).\n\t* @param {Array} obj object to traverse\n\t* @param {Object} target Object looked for\n\t* @returns {Boolean} True if the obj contains the value pass in\n\t*/\n\tvar __contains = function(obj, target) {\n\t\tif (obj === null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n\t\t\treturn obj.indexOf(target) !== -1;\n\t\t}\n\t\treturn __any(obj, function(value) {\n\t\t\treturn value === target;\n\t\t});\n\t};\n\n\t/* @func Produce a duplicate-free version of the array. If the array has already been sorted, you have the option of using a faster algorithm.\n\t* @param {Array} array object to traverse\n\t* @param {Boolean} isSorted indicate if the array is osrted or not\n\t* @param {Function} iterator If you want to compute unique items based on a transformation, pass an iterator function\n\t* @param {Object} context object from which extract keys\n\t* @returns {Array} Original array without duplicates\n\t*/\n\tvar __uniq = function(array, isSorted, iterator, context) {\n\t\tif (__isFunction(isSorted)) {\n\t\t\tcontext = iterator;\n\t\t\titerator = isSorted;\n\t\t\tisSorted = false;\n\t\t}\n\t\tvar initial = iterator ? __map(array, iterator, context) : array,\n\t\t\tresults = [],\n\t\t\tseen = [];\n\n\t\t__each(initial, function(value, index) {\n\t\t\tif (isSorted ? (!index || seen[seen.length - 1] !== value) : !__contains(seen, value))\n\t\t\t{\n\t\t\t\tseen.push(value);\n\t\t\t\tresults.push(array[index]);\n\t\t\t}\n\t\t});\n\t\treturn results;\n\t};\n\n\t/* @func Groups the object’s values by a criterion. Pass either a string attribute to group by, or a function that returns the criterion\n\t* @param {Array} obj object to traverse\n\t* @param {Function} iterator function called per each item founded in obj\n\t* @param {Object} context object from which extract keys\n\t* @returns {Object} Object where each property is the key of each group, and where the values of these key are the array of values grouped\n\t*/\n\tvar __groupBy = group(function(result, key, value) {\n\t\tif (__has(result, key))\n\t\t{\n\t\t\tresult[key].push(value);\n\t\t} else {\n\t\t\tresult[key] = [value];\n\t\t}\n\t});\n\n\t/* @func Uses a binary search to determine the index at which the value should be inserted into the list in order to maintain the list's sorted order.\n\t* @param {Array} array List of items to traverse\n\t* @param {Object} obj object to traverse\n\t* @param {Function} iterator Optional function that will be used to compute the sort ranking of each value, including the value (obj param) you pass.\n\t\tIterator may also be the string name of the property to sort by\n\t* @param {Object} context Used as a context when executing the iterator function\n\t* @returns {Integer} The location/index at which the pass value should be inserted.\n\t*/\n\tvar __sortedIndex = function(array, obj, iterator, context) {\n\t\titerator = lookupIterator(iterator);\n\t\tvar value = iterator.call(context, obj);\n\t\tvar low = 0,\n\t\t\thigh = array.length;\n\n\t\twhile (low < high) {\n\t\t\tvar mid = (low + high) >>> 1;\n\t\t\tif (iterator.call(context, array[mid]) < value)\n\t\t\t{\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn low;\n\t};\n\n\t/* @func Returns the index at which value can be found in the array, or -1 if value is not present in the array.\n\t* @param {Array} array List of items to traverse\n\t* @param {Object} item Object to find into the array\n\t* @param {Booelan} isSorted When the array is sorted pass true and the algorithm will perform a faster approach\n\t* @returns {Integer} The location/index at which the pass value is present, and -1 if the value is not present\n\t*/\n\tvar __indexOf = function (array, item, isSorted) {\n\t\tif (array === null) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar i = 0, length = array.length;\n\t\tif (isSorted) {\n\t\t\tif (typeof isSorted === 'number') {\n\t\t\t\ti = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n\t\t\t} else {\n\t\t\t\ti = __sortedIndex(array, item);\n\t\t\t\treturn array[i] === item ? i : -1;\n\t\t\t}\n\t\t}\n\n\t\tif (nativeIndexOf && array.indexOf === nativeIndexOf) {\n\t\t\treturn array.indexOf(item, isSorted);\n\t\t}\n\n\t\tfor (; i < length; i++) {\n\t\t\tif (array[i] === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tvar idCounter = 0;\n\t/* @func Generate a unique integer id (unique within the entire client session).\n\t* @param {String} prefix Optional prefix name\n\t* @returns {String} Unique identifier\n\t*/\n\tvar __uniqueId = function (prefix) {\n\t\tvar id = ++idCounter + '';\n\t\treturn prefix ? prefix + id : id;\n\t};\n\n\t/* @func Returns the last element of an array. Passing n will return the last n elements of the array..\n\t* @param {Integer} n Count of elements to return\n\t* @returns {[Object] || Object} Array with the last n values if n is specified or just the object of the array\n\t*/\n\tvar  __last = function (array, n, guard) {\n\t\tif (array === null || array === undefined)\n\t\t{\n\t\t\treturn void 0;\n\t\t}\n\t\tif (n === null || n === undefined || guard)\n\t\t{\n\t\t\treturn array[array.length - 1];\n\t\t}\n\t\treturn slice.call(array, Math.max(array.length - n, 0));\n\t};\n\n\t/*\n\t* @func Util function to shallow clone any kind of object\n\t* @param {Object} obj object to clone\n\t* @returns {Object} Shadow copy of the passed in object\n\t*/\n\tvar __shallowClone = function (obj)\n\t{\n\t\t//TODO TEST THIS\n\t\tif (!__isObject(obj))\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\n    \treturn __isArray(obj) ? obj.slice() : __extend({}, obj);\n\t};\n\n\treturn {\n\t\tinherit: __inherit,\n\t\textend: __extend,\n\t\textendInNew: __extendInNew,\n\t\tclone: __clone,\n\t\tisArray: __isArray,\n\t\tisString: __isString,\n\t\tisRegExp: __isRegExp,\n\t\tisNumber: __isNumber,\n\t\tisObject: __isObject,\n\t\tisFunction: __isFunction,\n\t\tisArguments: __isArguments,\n\t\tisBoolean: __isBoolean,\n\t\tisUndefined: __isUndefined,\n\t\tkeys: __keys,\n\t\teach: __each,\n\t\tmap: __map,\n\t\thas: __has,\n\t\treduce: __reduce,\n\t\tbind: __bind,\n\t\tfilter: __filter,\n\t\tany: __any,\n\t\tdefineProperty: __defineProperty,\n\t\tpluck: __pluck,\n\t\tsortBy: __sortBy,\n\t\tproperty: __property,\n\t\tfind: __find,\n\t\tevery: __every,\n\t\tflatten: __flatten,\n\t\tgroupBy: __groupBy,\n\t\tcontains: __contains,\n\t\tuniq: __uniq,\n\t\tsortedIndex: __sortedIndex,\n\t\tindexOf: __indexOf,\n\t\tuniqueId: __uniqueId,\n\t\tlast: __last,\n\t\tshallowClone: __shallowClone\n\t};\n})();\n","k.utils.str = (function()\n{\n\t'use strict';\n\n\t/*\n\t* @func Util function used to determine if a string starts with anotherone\n\t*\n\t* @param {String} source Original string\n\t* @param {String} input String to check for\n\t* @returns {Boolean} True if the source starts with input, false otherwise\n\t*/\n\tvar __startsWith = function(source, input) {\n\t\treturn source ? String.prototype.slice.call(source, 0, input.length) === input : false;\n\t};\n\n\t/*\n\t* @func Util function used to remove starting and ending spaces\n\t*\n\t* @param {String} str Original string\n\t* @returns {String} string without initial and final spaces\n\t*/\n\tvar __trim = function(str) {\n\t\treturn\tstr.replace(/^\\s+|\\s+$/g, '');\n\t};\n\n\t/*\n\t* @func Util function used to remove starting spaces NOT breaking lines\n\t*\n\t* @param {String} str Original string\n\t* @returns {String} string without initial spaces\n\t*/\n\tvar __ltrim = function(str) {\n\t\tvar space = /^[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000]+/;\n\t\treturn str.replace(space,'');\n\t};\n\n\t/*\n\t* @func Util function used to remove starting breaking lines\n\t*\n\t* @param {String} str Original string\n\t* @returns {String} string without initial enters\n\t*/\n\tvar __ltrimBreaks = function (str)\t{\n\t\treturn str.replace(/^[\\n\\r]+/,'');\n\t};\n\n\t/*\n\t* @func Util function used to remove starting spaces. This method DO remove left breaking lines\n\t*\n\t* @param {String} str Original string\n\t* @returns {String} string without initial spaces\n\t*/\n\tvar __fullLtrim = function (str)\n\t{\n\t\treturn str.replace(/^\\s+/,'');\n\t};\n\n\t/*\n\t* @func Util function used to remove ending spaces\n\t*\n\t* @param {String} str Original string\n\t* @returns {String} string without final spaces\n\t*/\n\tvar __rtrim = function(str) {\n\t\treturn str.replace(/\\s+$/,'');\n\t};\n\n\t/*\n\t* @func Util function used to remove starting and ending spaces\n\t*\n\t* @param {String} str Original string\n\t* @returns {String} string without initial and final spaces\n\t*/\n\tvar __fulltrim = function(str){\n\t\treturn str.replace(/(?:(?:^|\\n)\\s+|\\s+(?:$|\\n))/g,'').replace(/\\s+/g,' ');\n\t};\n\n\t/*\n\t* @func Generates a stirng that is composed by various tabs\n\t*\n\t* @param {String} counter Number of tabs to add\n\t* @returns {String} string composed by counter tabs\n\t*/\n\tvar __tabs = function (counter)\n\t{\n\t\tvar result = '';\n\t\tfor (var i = counter; i--; ) {\n\t\t\tresult += '\\t';\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn {\n\t\tstartsWith: __startsWith,\n\t\ttrim: __trim,\n\t\tltrim: __ltrim,\n\t\tltrimBreaks:__ltrimBreaks,\n\t\tfullLtrim: __fullLtrim,\n\t\trtrim: __rtrim,\n\t\tfulltrim: __fulltrim,\n\t\ttabs: __tabs\n\t};\n\n})();\n","/* Node\n * @class\n * @classdesc This class reprensent a generic Node class */\nk.data.Node = (function () {\n\t'use strict';\n\t\n\t/*\n\t * Constructor Generic Node for any kind of graph\n\t *\n\t * @constructor\n\t * @param {[Object]} options.transitions Array of object that initialy compone this node\n\t * @param {String} options.name Optioanl node identifiation\n\t * @param {[Node]} options.nodes Array of node instances that are children of this current node\n\t */\n\tvar node = function (options)\n\t{\n\t\tthis.options = options;\n\t\t\n\t\tk.utils.obj.defineProperty(this, 'transitions');\n\t\tk.utils.obj.defineProperty(this, 'nodes');\n\t\tk.utils.obj.defineProperty(this, 'name');\n\t\t\n\t\tk.utils.obj.defineProperty(this, '_id');\n\t\t\n\t\tthis.transitions = options.transitions || [];\n\t\tthis.nodes = options.nodes || [];\n\t};\n\t\n\t/* @function Returns the string ID of the current state\n\t * @returns {String} ID  */\n\tnode.prototype.getIdentity = function()\n\t{\n\t\tif (!this._id) {\n\t\t\tthis._id = this._generateIdentity();\n\t\t}\n\t\treturn this._id;\n\t};\n\t\n\t/* @function Generates an ID that identify this node from any other state\n\t * @returns {String} Generated ID  */\n\tnode.prototype._generateIdentity = function()\n\t{\n\t\treturn this.name || k.utils.obj.uniqueId('node_');\n\t};\n\t\n\t/* @function Add a new transaction into the list of transactions of the current state\n\t * @param {Object} transitionValue Object use to make the transition (i.e. symbol), description of the arista (like the name of the transition)\n\t * @param {Node} node Destination node (or state) arrived when moving with the specified tranisiotn\n\t * @returns {Void}  */\n\tnode.prototype.addTransition = function (transitionValue, node)\n\t{\n\t\tthis.transitions.push(this._generateNewTransition(transitionValue, node));\n\t\tthis.nodes.push(node);\n\t};\n\t\n\t/* @function Function responsible the creation of new transition objects\n\t * @param {Object} transitionValue Object use to make the transition, description of the arista (like the name of the transition)\n\t * @param {Node} node Destination node (or state) arrived when moving with the specified tranisiotn\n\t * @returns {Object} Transition object  */\n\tnode.prototype._generateNewTransition = function (transitionValue, node)\n\t{\n\t\treturn {\n\t\t\ttransitionValue: transitionValue,\n\t\t\tnode: node\n\t\t};\n\t};\n\t\n\t/* @function Gets the node identity\n\t* @returns {String} A formatted string id of the node */\n\tnode.prototype.toString = function ()\n\t{\n\t\treturn this.getIdentity();\n\t};\n\t\n\treturn node;\n})();\n","/* Enum for any special Symbol\n* @readonly\n* @enum {String}\n*/\nvar specialSymbol = k.data.specialSymbol = {\n\tEMPTY: 'EMPTY',\n\tEOF : 'EOF'\n};\n\n/* Enum Terminals Associativity\n* @readonly\n* @enum {String}\n*/\nvar associativity = k.data.associativity = {\n\tLEFT: 'LEFT',\n\tRIGHT: 'RIGHT'\n};\n\n/* Symbol\n* @class\n* @classdesc This class represent any simbol in the entire system */\nvar Symbol = k.data.Symbol = (function () {\n\t'use strict';\n\t\n\t/*\n\t* Creates an instance of a Symbol (This class represent non Terminals, Terminals and Special symbols)\n\t*\n\t* @constructor\n\t* @param {String} options.name The name or denatation of the non terminal\n\t* @param {Boolean} options.isSpecial Determiens if the current symbol is a secial one, like EOF. Default true\n\t* @param {Rule} options.rule Rule at which this particular instance of a symbol belongs to\n\t*/\n\tvar symbol = function (options)\n\t{\n\t\tthis.options = options;\n\n\t\tk.utils.obj.defineProperty(this, 'name');\n\t\tk.utils.obj.defineProperty(this, 'isSpecial');\n\t\tk.utils.obj.defineProperty(this, 'rule');\n\n\t\tthis.isSpecial = k.utils.obj.isBoolean(options.isSpecial) ? options.isSpecial : true;\n\n\t\tif (!this.name || !k.utils.obj.isString(this.name))\n\t\t{\n\t\t\tthrow new Error('Invalid initialization values for a symbol, please provide a string name a symbol');\n\t\t}\n\t};\n\t\n\t/* @function Shows the symbol's name\n\t* @returns {String} this.name */\n\tsymbol.prototype.toString = function() {\n\t\treturn this.name.toString();\n\t};\n\n\treturn symbol;\n})();\n\n/* Non Terminal\n* @class\n* @classdesc Use this class to create new instance of non Termianls */\nvar NonTerminal = k.data.NonTerminal = (function(_super) {\n\t'use strict';\n\t\n\t/* jshint latedef:false */\n\tk.utils.obj.inherit(nonTerminal, _super);\n\n\t/*\n\t* Creates an instance of a new Non Termianl\n\t*\n\t* @constructor\n\t* @param {String} options.name The name or denatation of the non terminal\n\t*/\n\tfunction nonTerminal (options)\n\t{\n\t\t_super.apply(this, arguments);\n\t\t\n\t\tk.utils.obj.defineProperty(this, 'isNullable'); // Control if the current non-terminal is nullable or not, This valus is calculate by the grammar's constructor\n\t\t\n\t\tthis.isNullable = false;\n\t\tthis.isSpecial = false;\n\t}\n\n\t/* @function Creates an array os non terminals from a string that represen them\n\t * @param {[Array]} arr Array of string used to create new non terminals\n\t * @returns {[NonTerminal]} An array of new nonterminals  */\n\tnonTerminal.fromArray = function (arr)\n\t{\n\t\tif (!k.utils.obj.isArray(arr) && !k.utils.obj.isString(arr)) {\n\t\t\tthrow new Error('Invalid parameter. To create non terminal from array the input parameter should be an array!');\n\t\t}\n\t\tvar result = [];\n\t\tk.utils.obj.each(arr, function(nonTerminalName)\n\t\t{\n\t\t\tresult[result.length] = new NonTerminal({name: nonTerminalName});\n\t\t});\n\n\t\treturn result;\n\t};\n\n\treturn nonTerminal;\n})(Symbol);\n\n/* Terminal\n* @class\n* @classdesc Use this class to repsent Termianls (like 'a', 'B', 'Hola', etc.) */\nvar Terminal = k.data.Terminal = (function(_super) {\n\t'use strict';\n\t\n\t/* jshint latedef:false */\n\tk.utils.obj.inherit(terminal, _super);\n\n\t/*\n\t* Creates an instance of a new Termianl\n\t*\n\t* @constructor\n\t* @param {String} options.name The name or denatation of the terminal\n\t* @param {String|RegExp} options.body The string or regexp used to match the input tokens\n\t*/\n\tfunction terminal (options)\n\t{\n\t\tif (!k.utils.obj.isString(options.body) && !k.utils.obj.isRegExp(options.body)) {\n\t\t\tthrow new Error('Invalid Terminal Initialization. A string or regexp body must be specified');\n\t\t}\n\t\toptions.name = options.name ? options.name : options.body.toString();\n\n\t\t_super.apply(this, arguments);\n\n\t\tk.utils.obj.defineProperty(this, 'body');\n\t\tk.utils.obj.defineProperty(this, 'isTerminal');\n\t\tk.utils.obj.defineProperty(this, 'assoc');\n\n\t\tthis.isSpecial = false;\n\t\tthis.isTerminal = true;\n\t}\n\n\t/* @function Shows the terminal's name between < and >\n\t* @returns {String} Fromatted string */\n\tterminal.prototype.toString = function()\n\t{\n\t\treturn '<' + this.name + '>';\n\t};\n\n\treturn terminal;\n})(Symbol);\n\n/* Grammatical Rules\n* @class\n* @classdesc Use this class to create new instance of non Termianls */\nvar Rule = k.data.Rule = (function() {\n\t'use strict';\n\t\n\t/*\n\t* Initialize a new Grammatical Rule\n\t*\n\t* @constructor\n\t* @param {NonTerminal} options.head The name or denatation of the non terminal\n\t* @param {[Terminal|NonTerminal]} options.tail Array of terminals and nonTerminals that represent the tail of the rule. If is not present an empty tail will be created.\n\t* @param {Function} options.reduceFunc A function to be executed when reducint this rule\n\t* @param {String} options.name Identification of the rule instance\n\t* @param {Number} options.precendence Optional number that indicate the precedence of the current rule\n\t*/\n\tvar rule = function (options)\n\t{\n\t\tthis.options = options;\n\n\t\tif (!options.head)\n\t\t{\n\t\t\tthrow new Error('Invalid initialization values, please provide a head for the rule');\n\t\t}\n\n\t\t//Define alias for:\n\t\tk.utils.obj.defineProperty(this, 'head');\n\t\tk.utils.obj.defineProperty(this, 'tail');\n\t\tk.utils.obj.defineProperty(this, 'reduceFunc');\n\t\tk.utils.obj.defineProperty(this, 'name');\n\t\tk.utils.obj.defineProperty(this, 'precendence');\n\n\t\tk.utils.obj.defineProperty(this, 'index');\n\t\tk.utils.obj.defineProperty(this, 'isProductive'); //Determine if the rule be active part of the grammar. This is calculate by the grammar itself\n\t\tk.utils.obj.defineProperty(this, 'isReachable'); //Determine if the rule is reachabke form the start symbol of the grammar. This is calculate by the grammar itself\n\t\tk.utils.obj.defineProperty(this, 'terminalsCount'); //Contains the number of terminals in the tail of the current rule\n\n\t\tthis.index = -1;\n\t\tthis.isProductive = false;\n\t\tthis.isReachable = false;\n\t\tthis.terminalsCount = 0;\n\n\t\tthis.head = !(options.head instanceof NonTerminal) ?\n\t\t\tnew NonTerminal({\n\t\t\t\tname: options.head.toString()\n\t\t\t}) :\n\t\t\toptions.head;\n\n\t\tthis.tail = (options.tail && k.utils.obj.isArray(options.tail)) ? options.tail : [new Symbol({name: specialSymbol.EMPTY, isSpecial: true})];\n\n\t\tk.utils.obj.each(this.tail, function (symbol)\n\t\t{\n\t\t\tif (symbol instanceof Terminal)\n\t\t\t{\n\t\t\t\tthis.terminalsCount++;\n\t\t\t}\n\t\t\tsymbol.rule = this;\n\t\t}, this);\n\t};\n\n\t/* @function Convert a Rule to its pritty string representation\n\t* @returns {String} Formatted string */\n\trule.prototype.toString = function()\n\t{\n\t\treturn this.head.toString() + ' --> ' + this.tail.join(' ');\n\t};\n\n\treturn rule;\n})();\n\n/* Grammar\n* @class\n* @classdesc This class is used to represent grammars */\nvar Grammar = k.data.Grammar = (function () {\n\t'use strict';\n\t\n\tvar defaultOptions = {\n\t\tname: ''\n\t};\n\n\t/*\n\t* Initialize a new Grammar\n\t*\n\t* @constructor\n\t* @param {NonTerminal} options.startSymbol Start symbol of the grammar\n\t* @param {[Rule]} options.rules Array of grammatical rules\n\t* @param {Boolean} options.preserveNonProductiveRules Determine if non-productive rules should be preserve or not. Default: false\n\t* @param {Boolean} options.preserveUnReachableRules Determine if unreachable rules should be preserve or not. Default: false\n\t* @param {String} options.name Optional name of the grammar\n\t*/\n\tvar grammar = function (options)\n\t{\n\t\tthis.options = k.utils.obj.extendInNew(defaultOptions, options || {});\n\n\t\t//Define alias for:\n\t\tk.utils.obj.defineProperty(this, 'startSymbol');\n\t\tk.utils.obj.defineProperty(this, 'name');\n\t\tk.utils.obj.defineProperty(this, 'rules');\n\t\tk.utils.obj.defineProperty(this, 'preserveNonProductiveRules');\n\t\tk.utils.obj.defineProperty(this, 'preserveUnReachableRules');\n\n\t\tk.utils.obj.defineProperty(this, 'specifiedStartSymbol'); //After augmented the grammar this property save the specified start symbol (it should be read only)\n\t\tk.utils.obj.defineProperty(this, 'terminals');\n\t\tk.utils.obj.defineProperty(this, 'rulesByHeader');\n\t\tk.utils.obj.defineProperty(this, 'firstSetsByHeader');\n\t\tk.utils.obj.defineProperty(this, 'nullableNonTerminals');\n\n\t\tif (!(this.startSymbol instanceof Symbol))\n\t\t{\n\t\t\tthrow new Error('Invalid grammar creation, please specify a start Symbol!');\n\t\t}\n\n\t\tthis.nullableNonTerminals = [];\n\t\tthis._generateRequireRequisites();\n\t};\n\n\tgrammar.constants = {\n\t\tAugmentedRuleName: 'AUGMENTRULE'\n\t};\n\t\n\t/* @function Determines if a rule is productive or not based on the CURRENT state of all the rest of the rules in the grammar\n\t* @param {Rule} rule Rule that will be analized\n\t* @returns {Boolean} True if the rule is productive, false otherwise */\n\tgrammar.prototype._isRuleProductive = function (rule)\n\t{\n\t\t//find NONProductive tail symbols\n\t\treturn !k.utils.obj.find(rule.tail, function (symbol)\n\t\t{\n\t\t\t// the tail symnol is a non terminal, that; has rules and its rule are all invalid, OR not have any rule\n\t\t\tif (symbol instanceof NonTerminal &&\n\t\t\t\t(\n\t\t\t\t\t(this.rulesByHeader[symbol.name] && k.utils.obj.every(this.rulesByHeader[symbol.name], function (rule) { return !rule.isProductive; } ) ) ||\n\t\t\t\t\t(!this.rulesByHeader[symbol.name])\n\t\t\t\t)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}, this);\n\t};\n\n\t/* @function Generate require state for a grammar.\n\t* Set rule index\n\t* Augment the grammar to detect when a string is accepts by adding S' --> S#\n\t* Calculate rules by head\n\t* @returns {Void} */\n\tgrammar.prototype._generateRequireRequisites = function ()\n\t{\n\t\t// augment the grammar\n\t   var augmentedRule = this._augmentGrammar(this.startSymbol, this.startSymbol);\n\n\t\t//set rules index\n\t\tk.utils.obj.each(this.rules, function (rule, i) {\n\t\t\trule.index = i;\n\t\t});\n\n\n\t\t// index rule by its rule's head name\n\t\tthis._indexRulesByHead();\n\t\t\n\t\t\n\t\t// determine which rules are productive and remove unproductive ones\n\t\taugmentedRule = this._cleanUnProductiveRules() || augmentedRule;\n\t\tthis._indexRulesByHead();\n\t\t\n\t\t\n\t\t//Remove unreachabel rules\n\t\tthis._cleanUnReachableRules(augmentedRule);\n\t\tthis._indexRulesByHead();\n\t\t\n\t\t\n\t\t// remove middle tail epsilons\n\t\tthis._removeMiddleTailEpsilons();\n\n\n\t\t//Determines nullable non-terminals\n\t\tthis._determineNullableNonTerminals();\n\t\t\n\t\t\n\t\t// get all terminals & determine if it has empty rules\n\t\tthis.terminals = this._generateListOfTerminals();\n\t\t\n\t\t\n\t\t//Pre-Calculate First Sets\n\t\tthis.firstSetsByHeader = this._precalculateFirstTerminals();\n\t};\n\t\n\t/* @function Index all the current rules in the rulesByHeader local property \n\t* @returns {Void} It does not return anything as the values are stored in this.rulesByHeader. */\n\tgrammar.prototype._indexRulesByHead = function ()\n\t{\n\t\tthis.rulesByHeader = k.utils.obj.groupBy(this.rules, function (rule)\n\t\t{\n\t\t\treturn rule.head.name;\n\t\t});\n\t};\n\t\n\t/* @function Calculate the first set for all non-terminals of the current grammar\n\t* @returns {Object} Object when each property is a non-terminal name and its values are the first sets. */\n\tgrammar.prototype._precalculateFirstTerminals = function ()\n\t{\n\t\tvar result = {};\n\t\t\n\t\tk.utils.obj.each(k.utils.obj.keys(this.rulesByHeader), function (ruleHead)\n\t\t{\n\t\t\tresult[ruleHead] = this._calculateFirstSetForHead(ruleHead);\n\t\t}, this);\n\t\t\n\t\treturn result;\n\t};\n\t\n\t/* @function Calculate the first set for specific non-terminal symbol\n\t* @param {String} head Name of the head rule to which the First Set will be determined\n\t* @param {[String]} recursionStack Internal recursion array used to control infinite loops\n\t* @returns {[Terminals]} Array of terminals (possibly plus EMPTY - the special symbol) FIRST SET */\n\tgrammar.prototype._calculateFirstSetForHead = function (head, recursionStack)\n\t{\n\t\t/*\n\t\tThis method has as a preconditions:\n\t\t-All duplicated epsilon have already being removed\n\t\t-Unreachabel rules have been removed\n\t\t-Nullable non terminals detected\n\t\t-The rulesByHeader object\n\t\t*/\n\t\t\n\t\tvar result = [];\n\t\t\t\n\t\trecursionStack = recursionStack || {};\n\t\t\n\t\tk.utils.obj.each(this.rulesByHeader[head], function(rule) {\n\t\t\t\n\t\t\tk.utils.obj.find(rule.tail, function (symbol)\n\t\t\t{\n\t\t\t\tif (symbol instanceof NonTerminal)\n\t\t\t\t{\n\t\t\t\t\tif (recursionStack[symbol.name])\n\t\t\t\t\t{\n\t\t\t\t\t\t//When we found a recursive (or just a symbol that apear more than one in a same rule or in different rules of the same symbol head) symbol (non-terminal) we SKIP IT (continue with the next item in the tail) IF it is NULLABLE,\n\t\t\t\t\t\t//otherwise if it is NOT NULLABLE we STOP our SEARCH of first item as the current rule will not generate the desire first items (because we are in a recursive case)\n\t\t\t\t\t\treturn !symbol.isNullable;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\trecursionStack[symbol.name] = true;\n\t\t\t\t}\n\t\t\t\telse if (symbol.isSpecial && symbol.name === specialSymbol.EOF)\n\t\t\t\t{\n\t\t\t\t\treturn true; //finish the search of terminal first symbols for the current rule\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (symbol instanceof Terminal || (symbol.name === specialSymbol.EMPTY && symbol.isSpecial))\n\t\t\t\t{\n\t\t\t\t\tresult.push(symbol);\n\t\t\t\t}\n\t\t\t\telse if (symbol instanceof NonTerminal)\n\t\t\t\t{\n\t\t\t\t\tresult = result.concat(k.utils.obj.flatten(this._calculateFirstSetForHead(symbol.name, recursionStack), true));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new Error('Impossible to calculate FIRST Set, some rules have invalid tail symbols');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Continue adding items to the FIRST Set if the current result contains EMPTY\n\t\t\t\treturn !k.utils.obj.find(result, function (possible_empty_symbol)\n\t\t\t\t{\n\t\t\t\t\treturn possible_empty_symbol.name === specialSymbol.EMPTY;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}, this);\n\t\t\t\n\t\t}, this);\n\t\t\n\t\treturn k.utils.obj.uniq(result, false, function (item) {return item.name;});\n\t};\n\t\n\t/* @function Augments the current grammar by adding a new initial production of the form S' -> S #\n\t* @returns {Rule} The new generated rule */\n\tgrammar.prototype._augmentGrammar = function (newSubStartSymbol, oldStartSymbol)\n\t{\n\t\tthis.specifiedStartSymbol = oldStartSymbol;\n\t\tvar augmentedRule = new Rule({\n\t\t\thead: 'S\\'',\n\t\t\ttail: [newSubStartSymbol, new k.data.Symbol({name: specialSymbol.EOF, isSpecial: true})],\n\t\t\tname: grammar.constants.AugmentedRuleName\n\t\t});\n\n\t\tthis.rules.unshift(augmentedRule);\n\t\tthis.startSymbol = augmentedRule.head;\n\t\t\n\t\treturn augmentedRule;\n\t};\n\t\n\t/* @function Determiens which rules are non-productive and remove them based on the current options\n\t* @returns {Rule} In case the affter applying this cleaning process all rule are removed, a new augmented rule is generated and returned */\n\tgrammar.prototype._cleanUnProductiveRules = function ()\n\t{\n\t\t//Remove \"Don't make functions within a loop\" warning\n\t\t/*jshint -W083 */\n\t\tvar areChanges = false,\n\t\t\truleIndex = 0,\n\t\t\taugmentedRule;\n\t\t\n\t\tdo {\n\t\t\tareChanges = false;\n\t\t\tk.utils.obj.each(this.rules, function (rule)\n\t\t\t{\n\t\t\t\tif (!rule.isProductive)\n\t\t\t\t{\n\t\t\t\t\trule.isProductive = this._isRuleProductive(rule);\n\t\t\t\t\tareChanges = areChanges || rule.isProductive;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t} while (areChanges);\n\t\t\n\t\tif (!this.preserveNonProductiveRules)\n\t\t{\n\t\t\twhile (ruleIndex < this.rules.length)\n\t\t\t{\n\t\t\t\tif (!this.rules[ruleIndex].isProductive) {\n\t\t\t\t\tthis.rules.splice(ruleIndex, 1);\n\t\t\t\t} else {\n\t\t\t\t\truleIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (this.rules.length === 0)\n\t\t\t{\n\t\t\t\t//In this case the augmentation rule does not have a tail! S' --> <EMPTY> EOF\n\t\t\t\taugmentedRule = this._augmentGrammar(new k.data.Symbol({name: specialSymbol.EMPTY, isSpecial: true}), this.specifiedStartSymbol);\n\t\t\t\taugmentedRule.index = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn augmentedRule;\n\t};\n\t\n\t/* @function Removes each epsilon located in the middle of a rule's tail, as they no add any value but make more complicated the rest of the parser\n\t* @returns {Void} */\n\tgrammar.prototype._removeMiddleTailEpsilons = function ()\n\t{\n\t\tvar tailIndex = 0;\n\t\tk.utils.obj.each(this.rules, function (rule)\n\t\t{\n\t\t\ttailIndex = 0;\n\t\t\t\n\t\t\twhile (tailIndex < rule.tail.length)\n\t\t\t{\n\t\t\t\t// if the current tail symbol is an empty one\n\t\t\t\tif (rule.tail[tailIndex].isSpecial && rule.tail[tailIndex].name === k.data.specialSymbol.EMPTY)\n\t\t\t\t{\n\t\t\t\t\t//if it is not the last one or the previous one is not empty\n\t\t\t\t\tif ( ((tailIndex + 1) < rule.tail.length && (!rule.tail[tailIndex + 1].isSpecial || rule.tail[tailIndex + 1].name !== specialSymbol.EOF)) || \n\t\t\t\t\t\t(tailIndex === (rule.tail.length -1) && tailIndex > 0 && !rule.tail[tailIndex-1].isSpecial) )\n\t\t\t\t\t{\n\t\t\t\t\t\trule.tail.splice(tailIndex, 1);\n\t\t\t\t\t\t--tailIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttailIndex++;\n\t\t\t}\n\t\t});\n\t};\n\t\n\t/* @function Determine which rules are unreachable and based on the current options remove this rules\n\t* @param {Rule} augmentedRule The extra added new initial rule\n\t* @returns {Void} */\n\tgrammar.prototype._cleanUnReachableRules = function (augmentedRule)\n\t{\n\t\t//Remove \"Don't make functions within a loop\" warning\n\t\t/*jshint -W083 */\n\t\tvar areChanges = false,\n\t\t\truleIndex = 0;\n\t\t\n\t\taugmentedRule.isReachable = true;\n\t\tdo\n\t\t{\n\t\t\tareChanges = false;\n\t\t\tk.utils.obj.each(this.rules, function (rule)\n\t\t\t{\n\t\t\t\tif (rule.isReachable)\n\t\t\t\t{\n\t\t\t\t\tk.utils.obj.each(rule.tail, function (symbol)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (symbol instanceof NonTerminal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk.utils.obj.each(this.rulesByHeader[symbol.name], function (rule)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!rule.isReachable)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tareChanges = true;\n\t\t\t\t\t\t\t\t\trule.isReachable = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t} while (areChanges);\n\t\t\n\t\tif (!this.preserveUnReachableRules)\n\t\t{\n\t\t\truleIndex = 0;\n\t\t\twhile (ruleIndex < this.rules.length)\n\t\t\t{\n\t\t\t\tif (!this.rules[ruleIndex].isReachable) {\n\t\t\t\t\tthis.rules.splice(ruleIndex, 1);\n\t\t\t\t} else {\n\t\t\t\t\truleIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/* @function Generate a list of all the terminals the current grammar has. This list is used by the Lexer\n\t* @returns {[Terminal]} An array of all uniq terminals in the current grammar  */\n\tgrammar.prototype._generateListOfTerminals = function ()\n\t{\n\t\tvar tailSymbols = k.utils.obj.flatten(\n\t\t\t\tk.utils.obj.map(this.rules, function (rule)\n\t\t\t\t{\n\t\t\t\t\treturn rule.tail;\n\t\t\t\t}),\n\t\t\t\tfalse);\n\n\t\t// remove duplicated symbol (by its name) and filter all non terminals\n\t\treturn k.utils.obj.filter(\n\t\t\tk.utils.obj.uniq(tailSymbols, false, function (symbol)\n\t\t\t{\n\t\t\t\treturn symbol.name;\n\t\t\t}),\n\t\t\tfunction (symbol)\n\t\t\t{\n\t\t\t\treturn symbol.isTerminal;\n\t\t\t});\n\t};\n\n\t/* @function Mark all non-terminales that are nullable with a flag isNullable set in true\n\t* @returns {Void} */\n\tgrammar.prototype._determineNullableNonTerminals = function ()\n\t{\n\t\t//Remove \"Don't make functions within a loop\" warning\n\t\t/*jshint -W083 */\n\t\tvar allNonTerminalAreNullablesInRule = false,\n\t\t\tareChanges = false;\n\t\t\t\n\t\tdo {\n\t\t\tareChanges = false;\n\t\t\t\n\t\t\tk.utils.obj.each(this.rules, function (rule)\n\t\t\t{\n\t\t\t\tif (rule.tail.length === 1 && rule.tail[0].name === k.data.specialSymbol.EMPTY && !rule.head.isNullable)\n\t\t\t\t{\n\t\t\t\t\trule.head.isNullable = true;\n\t\t\t\t\tareChanges = true;\n\t\t\t\t\tthis.nullableNonTerminals.push(rule.head.name);\n\t\t\t\t}\n\t\t\t\telse if (rule.terminalsCount === 0)\n\t\t\t\t{\n\t\t\t\t\tallNonTerminalAreNullablesInRule = k.utils.obj.every(rule.tail, function (nonTerminal)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn this.nullableNonTerminals.indexOf(nonTerminal.name) >= 0;\n\t\t\t\t\t}, this);\n\t\t\t\t\t\n\t\t\t\t\tif (allNonTerminalAreNullablesInRule && !rule.head.isNullable)\n\t\t\t\t\t{\n\t\t\t\t\t\trule.head.isNullable = true;\n\t\t\t\t\t\tareChanges = true;\n\t\t\t\t\t\tthis.nullableNonTerminals.push(rule.head.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t} while (areChanges);\n\t\t\n\t\tvar allRulesSymbols = k.utils.obj.flatten(\n\t\t\t\tk.utils.obj.map(this.rules, function (rule)\n\t\t\t\t{\n\t\t\t\t\treturn rule.tail.concat(rule.head);\n\t\t\t\t}),\n\t\t\t\tfalse);\n\t\t\t\t\n\t\t// Mark all non terminals that were determined in the previous step, as nullables. This is require because besides share the same name, each non-temrinal in diferentes rules are different isntances\n\t\tvar allNullablesNonTerminals = k.utils.obj.filter(allRulesSymbols, function (symbol) {\n\t\t   return symbol instanceof NonTerminal && this.nullableNonTerminals.indexOf(symbol.name) >= 0;\n\t\t}, this);\n\t\t\n\t\tk.utils.obj.each(allNullablesNonTerminals, function(nonTerminal) {\n\t\t\tnonTerminal.isNullable = true;\n\t\t});\n\t};\n\n\t/* @function Returns the list of rules that start with the specified symbols as the head\n\t* @param {Symbol} symbol Symbol used as the head of the requested rules\n\t* @returns {[Rules]} Array of rules */\n\tgrammar.prototype.getRulesFromNonTerminal = function(symbol)\n\t{\n\t\treturn this.rulesByHeader[symbol.name];\n\t};\n\n\t/* @function Convert a Grammar to its pritty string representation\n\t* @returns {String} Formatted string */\n\tgrammar.prototype.toString = function()\n\t{\n\t\tvar strResult = this.name ? 'Name: ' + this.name + '\\n' : '';\n\t\tstrResult += 'Start Symbol: ' + this.startSymbol.name +'\\n';\n\n\t\tstrResult += k.utils.obj.reduce(k.utils.obj.sortBy(this.rules, function(rule) {return rule.index;}), function (strAcc, rule) {\n\t\t\treturn strAcc + '\\n' + rule.index + '. ' + rule.toString();\n\t\t}, '');\n\n\t\treturn strResult;\n\t};\n\n\treturn grammar;\n})();","/* ASTNode\n * @class\n * @classdesc This class reprensent an AST NODE, a sub-type of a generic Node */\nk.data.ASTNode = (function(_super) {\n\t'use strict';\n\t\n\t/* jshint latedef:false */\n\tk.utils.obj.inherit(astNode, _super);\n\t\n\t/*\n\t * Constructor AST Node\n\t *\n\t * @constructor\n\t * @param {Rule} options.rule Asociated reduce rule that originate the node creation\n\t * @param {String} options.stringValue Optional string chunk that originate the node creation\n\t * @param {Symbol} options.symbol Optional Symbol. Used ad the head of the rule that is related with the current ASTNode\n\t * @param {[Object]} options.transitions Array of object that initialy compone this node\n\t * @param {[Node]} options.nodes Array of Nodes instances (or just objects) that are children of this Node\n\t */\n\tfunction astNode (options)\n\t{\n\t\t_super.apply(this, arguments);\n\n\t\tk.utils.obj.defineProperty(this, 'rule');\n\t\tk.utils.obj.defineProperty(this, 'stringValue');\n\t\tk.utils.obj.defineProperty(this, 'currentValue');\n\t\tk.utils.obj.defineProperty(this, 'symbol');\n\t}\n\n\t/* @function Generates a string representation of the current AST Node\n\t * @param {Boolean} options.deep True in case to print the entire node and its children\n\t * @returns {String} formatted string */\n\tastNode.prototype.toString = function(options)\n\t{\n\t\tif (options && !k.utils.obj.isUndefined(options.deep))\n\t\t{\n\t\t\toptions.deep = k.utils.obj.isNumber(options.deep) ? options.deep : 0;\n\t\t\tvar tabs = k.utils.str.tabs(options.deep);\n\t\t\t++options.deep;\n\t\t\t\n\t\t\treturn tabs + this._toCurrentString() + '\\n' + k.utils.obj.reduce(this.nodes, function (acc, node) {\n\t\t\t\treturn acc + (k.utils.obj.isString(node) ? k.utils.str.tabs(options.deep) + node + '\\n' : node.toString({deep: options.deep}));\n\t\t\t},'');\n\t\t} \n\t\t\n\t\treturn this._toCurrentString();\n\t};\n\t\n\t/* @function Generates a string representation of the current AST Node\n\t * @returns {String} formatted string */\n\tastNode.prototype._toCurrentString = function ()\n\t{\n\t\treturn this.getIdentity() + (this.rule ? ': '+ this.rule.toString() + ' (' + this.currentValue + ')' : '');\n\t};\n\t\n\treturn astNode;\n})(k.data.Node);","/* Item Rule\n* @class\n* @classdesc This class represent an Item. A rule being processed. Generally a dot is used to represent which part have already been\nprocessed. Ex. S ==> aB*AB */\nvar ItemRule = k.data.ItemRule = (function() {\n\t'use strict';\n\t\n\tvar defaultCloneOptions = {\n\t\tdotLocationIncrement: 0\n\t};\n\n\t/*\n\t* Constructor for a Item Rule\n\t*\n\t* @constructor\n\t* @param {Rule} options.rule Rule wich is pointed be this item\n\t* @param {Integer} options.dotLocation Index at the tail of the rule that have already been processed\n\t*/\n\tvar itemRule = function(options)\n\t{\n\t\tthis.options = options;\n\n\t\t//Define alias for the next properties\n\t\tk.utils.obj.defineProperty(this, 'rule');\n\t\tk.utils.obj.defineProperty(this, 'dotLocation');\n\t\tk.utils.obj.defineProperty(this, 'lookAhead');\n\t\t\n\t\tk.utils.obj.defineProperty(this, '_id');\n\n\t\tthis.lookAhead = this.lookAhead || [];\n\t\tthis.dotLocation = options.dotLocation || 0;\n\t\t\n\t\tif (this.rule && this.rule.tail.length === 1 && this.rule.tail[0].name === k.data.specialSymbol.EMPTY)\n\t\t{\n\t\t\t//Empty rules are reduce items\n\t\t\tthis.dotLocation = 1;\n\t\t}\n\t};\n\n\t/* @function Convert the current item rule to its string representation\n\t* @returns {String} formatted string */\n\titemRule.prototype.toString = function()\n\t{\n\t\tvar aux = this.getIdentity() + '.  ' + this.rule.head.name +'-->';\n\t\tfor (var i = 0; i < this.rule.tail.length; i++)\n\t\t{\n\t\t\taux += (this.dotLocation === i ? '*': ' ') + this.rule.tail[i].toString();\n\t\t}\n\t\tif (this.dotLocation === i) {\n\t\t\taux += '*';\n\t\t}\n\t\taux += ',    [' + this.lookAhead.join(', ') + ']';\n\t\treturn aux;\n\t};\n\n\t/* @function Clone the current item, altering its state by the params specified in cloneUpdateOptions\n\t* @param {Integer} cloneUpdateOptions.dotLocationIncrement Increment that will be applied into the dot location of the new item. Default: 0\n\t* @param {Object} creationOptions Optional object use to expand current option used to create the returned clone\n\t* @returns {ItemRule} A clean new item */\n\titemRule.prototype.clone = function(cloneUpdateOptions, creationOptions)\n\t{\n\t\tvar updateOptions = k.utils.obj.extendInNew(defaultCloneOptions, cloneUpdateOptions || {}),\n\t\t\tcloneOptions = this._cloneCurrentOptions(cloneUpdateOptions, creationOptions);\n\n\t\tvar result = new ItemRule(cloneOptions);\n\t\tresult._incrementDotLocation(updateOptions.dotLocationIncrement);\n\t\tresult._id = null;\n\n\t\treturn result;\n\t};\n\n\t/* @function Clone the current item's options\n\t* @param {Object} cloneUpdateOptions Optional object use to control the way the options are being cloned\n\t* @param {Object} extendedOptions Optional object use to expand current options and create the returned clone\n\t* @returns {Object} A copy of the current options (The referenced rule is not copied, hte same rule instance is used) */\n\titemRule.prototype._cloneCurrentOptions = function(cloneUpdateOptions, extendedOptions)\n\t{\n\t\tvar ruleAux = this.rule,\n\t\t\tlookAheadAux = this.lookAhead;\n\t\t\t\n\t\tthis.rule = this.lookAhead = null;\n\t\t\n\t\tvar result = k.utils.obj.extendInNew(this.options, extendedOptions || {});\n\t\t\n\t\tthis.rule = result.rule = ruleAux;\n\t\tthis.lookAhead = lookAheadAux;\n\t\tresult.lookAhead = [].concat(lookAheadAux);\n\n\t\treturn result;\n\t};\n\n\t/* @function Increase the dot location by the number specified by parameter\n\t* @param {Integer} increment Increment that will be applied into the dot location of the new item. Default: 1\n\t* @returns {Void} */\n\titemRule.prototype._incrementDotLocation = function(increment)\n\t{\n\t\tvar optionsValue = k.utils.obj.isNumber(this.options.dotLocation) ? this.options.dotLocation : 0,\n\t\t\tincrementValue = k.utils.obj.isNumber(increment) ? increment : 1;\n\n\t\tthis.dotLocation = optionsValue + incrementValue;\n\t};\n\t\n\t/* @function Gets a string id that uniquely identity the current item rule\n\t* @returns {String} Id */\n\titemRule.prototype.getIdentity = function ()\n\t{\n\t\tif (!this._id)\n\t\t{\n\t\t\tthis._id = this._generateIdentity();\n\t\t}\n\t\treturn this._id;\n\t};\n\t\n\t/* @function Internal method to generate a unique Id\n\t* @returns {String} Id */\n\titemRule.prototype._generateIdentity = function ()\n\t{\n\t\treturn this.rule.index + '(' + this.dotLocation + ')';\n\t};\n\n\t/* @function Returns the right next symbol to the dot location\n\t* @returns {Symbol} Next symbol or null if there is not next symbol */\n\titemRule.prototype.getCurrentSymbol = function ()\n\t{\n\t\t// When the dot location is the same as tail length is a reduce item.\n\t\t// In this case the next item is null\n\t\treturn this.dotLocation < (this.rule.tail.length + 1) ? this.rule.tail[this.dotLocation] : null;\n\t};\n\t\n\t/* @function Determines if the current item rule is a reduce one or not\n\t* @returns {Boolean} True if the current item is a reduce item, false otherwise */\n\titemRule.prototype.isReduce = function ()\n\t{\n\t\treturn this.dotLocation === this.rule.tail.length;\n\t};\n\n\t/* @function Create an array of item rules from an array of rules\n\t* @param {[Rule]} rules Array of rules used to create the item rules. Each new item rule will have 0 as dot location\n\t* @param {[Symbol]} lookAhead Array of symbols that will be set to each of the item rules created as its lookahead array\n\t* @returns {[ItemRule]} Array of new Item Rules */\n\titemRule.newFromRules = function(rules, lookAhead)\n\t{\n\t\treturn k.utils.obj.reduce(rules, function (acc, rule)\n\t\t{\n\t\t\tacc.push(new ItemRule({\n\t\t\t\trule: rule,\n\t\t\t\tdotLocation: 0,\n\t\t\t\tlookAhead: [].concat(lookAhead || [])\n\t\t\t}));\n\t\t\treturn acc;\n\t\t}, []);\n\t};\n\n\treturn itemRule;\n})();\n","/* StackItem\n* @class\n* @classdesc Each instance of this class will be used by the parse to represent a state into the stack */\nk.data.StackItem = (function() {\n\t'use strict';\n\t/*\n\t* Creates an instance of a Parser \n\t*\n\t* @constructor\n\t* @param {Object} options.state (Require) The current state\n\t* @param {Object} options.currentValue The Optional result of getting this stack Item. This property is used by the grammar creator to make on-going processing of the being build AST.\n\t* @param {Symbol} options.stringValue In case that this stack item is created by a TERMINAL reduction or shift, the associated string that generate the stack item creation is attached.\n\t* @param {Symbol} options.symbol The Optional Current Symbol of the stack item\n\t* @param {Automata} options.AST Optional underprocessing AST. The Sub-tree AST for the current node\n\t*/\n\tvar stackItem = function(options) {\n\t\tthis.options = options;\n\n\t\tk.utils.obj.defineProperty(this, 'state');\n\t\tk.utils.obj.defineProperty(this, 'currentValue');\n\t\tk.utils.obj.defineProperty(this, 'stringValue');\n\t\tk.utils.obj.defineProperty(this, 'symbol');\n\t\tk.utils.obj.defineProperty(this, 'AST');\n\t\t\n\t\tif (!this.state) {\n\t\t\tthrow new Error('Invalid initialization values for a Stack Item, please provide a valid state');\n\t\t}\n\t};\n\t\n\treturn stackItem;\n})();\n","/* State\n * @class\n * @classdesc This class reprensent an automata state, a sub-type of a generic Node */\nk.data.State = (function(_super)\n{\n\t'use strict';\n\t/* jshint latedef:false */\n\tk.utils.obj.inherit(state, _super);\n\n\t/*\n\t * Constructor Automata State\n\t *\n\t * @constructor\n\t * @param {[ItemRule]} options.items Array of item rules that initialy compone this state\n\t * @param {[Object]} options.transitions Array of object that initialy compone this node\n\t * @param {[Node]} options.nodes Array of State instances that are children of this State\n\t */\n\tfunction state (options) {\n\n\t\t_super.apply(this, arguments);\n\n\t\tk.utils.obj.defineProperty(this, 'isAcceptanceState'); // This is set by the automata generator\n\n\t\tk.utils.obj.defineProperty(this, '_items');\n\t\tk.utils.obj.defineProperty(this, '_registerItems');\n\t\tk.utils.obj.defineProperty(this, '_condencedView');\n\t\tk.utils.obj.defineProperty(this, '_unprocessedItems');\n\n\t\tthis.isAcceptanceState = false;\n\n\t\tthis._items = options.items || [];\n\t\tthis._unprocessedItems = this._items.length ? k.utils.obj.shallowClone(this._items) : [];\n\t\toptions.items = null;\n\n\t\tthis._registerItems = {};\n\n\t\tthis._registerItemRules();\n\t}\n\n\t/* @function REgister the list of item rules of the current stateso they are assesible by its id\n\t * @returns {Void} */\n\tstate.prototype._registerItemRules = function ()\n\t{\n\t\tk.utils.obj.each(this._items, function (itemRule)\n\t\t{\n\t\t\tthis._registerItems[itemRule.getIdentity()] = itemRule;\n\t\t}, this);\n\t};\n\n\tstate.constants = {\n\t\tAcceptanceStateName: 'AcceptanceState'\n\t};\n\n\t/* @function Get the next unprocessed item rule\n\t * @returns {ItemRule} Next Item Rule */\n\tstate.prototype.getNextItem = function() {\n\t\treturn this._unprocessedItems.splice(0,1)[0];\n\t};\n\n\t/* @function Adds an array of item rule into the state. Only the rules that are not already present in the state will be added\n\t * @param {[ItemRule]} itemRules Array of item rules to add into the state\n\t * @param {Boolean} options.notMergeLookAhead If specified as true does not marge the lookAhead of the already existing items. Default: falsy\n\t * @returns {void} Nothing */\n\tstate.prototype.addItems = function(itemRules, options) {\n\n\t\tthis._id = null;\n\t\tk.utils.obj.each(itemRules, function (itemRule)\n\t\t{\n\t\t\t// The same item rule can be added more than once if the grammar has loops.\n\t\t\t// For sample: (1)S -> A *EXPS B      (2)EXPS -> *EXPS\n\t\t\tif (!this._registerItems[itemRule.getIdentity()])\n\t\t\t{\n\t\t\t\tthis._registerItems[itemRule.getIdentity()] = itemRule;\n\t\t\t\tthis._items.push(itemRule);\n\t\t\t\tthis._unprocessedItems.push(itemRule);\n\t\t\t}\n\t\t\telse if (!options || !options.notMergeLookAhead)\n\t\t\t{\n\t\t\t\t//As a way of generating a LALR(1) automata adds a item rule for each lookAhead we simply merge its lookAheads\n\t\t\t\tvar original_itemRule = this._registerItems[itemRule.getIdentity()];\n\n\t\t\t\tif (itemRule.lookAhead && itemRule.lookAhead.length)\n\t\t\t\t{\n\t\t\t\t\toriginal_itemRule.lookAhead = original_itemRule.lookAhead || [];\n\t\t\t\t\titemRule.lookAhead = itemRule.lookAhead || [];\n\n\t\t\t\t\tvar mergedLookAheads = original_itemRule.lookAhead.concat(itemRule.lookAhead),\n\t\t\t\t\t\toriginal_itemRule_lookAhead_length = this._registerItems[itemRule.getIdentity()].lookAhead.length;\n\n\t\t\t\t\tthis._registerItems[itemRule.getIdentity()].lookAhead = k.utils.obj.uniq(mergedLookAheads, function (item) { return item.name;});\n\n\t\t\t\t\tvar is_item_already_queued = k.utils.obj.filter(this._unprocessedItems, function (unprocessed_item)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn unprocessed_item.getIdentity() === itemRule.getIdentity();\n\t\t\t\t\t}).length > 0;\n\n\t\t\t\t\t//If there were changes in the lookAhead and the rule is not already queued.\n\t\t\t\t\tif (original_itemRule_lookAhead_length !== this._registerItems[itemRule.getIdentity()].lookAhead.length && !is_item_already_queued)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._unprocessedItems.push(itemRule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t};\n\n\t/* @function Convert the current state to its string representation\n\t * @returns {String} formatted string */\n\tstate.prototype.toString = function() {\n\t\tvar strResult = 'ID: ' + this.getIdentity() + '\\n' +\n\t\t\t\t\t\tthis._items.join('\\n') +\n\t\t\t\t\t\t'\\nTRANSITIONS:\\n';\n\n\t\tk.utils.obj.each(this.transitions, function (transition)\n\t\t{\n\t\t\tstrResult += '*--' + transition.symbol + '-->' + transition.state.getIdentity() + '\\n';\n\t\t});\n\t\treturn strResult;\n\t};\n\n\t/* @function Returns the condenced (one line) string that reprenset the current 'state' of the current state\n\t * @returns {String} State Representation in one line  */\n\tstate.prototype.getCondencedString = function() {\n\t\tif(!this._condencedView)\n\t\t{\n\t\t\tthis._condencedView = this._generateCondencedString();\n\t\t}\n\t\treturn this._condencedView;\n\t};\n\n\t/* @function Internal method to generate a condenced (one line) string that reprenset the current 'state' of the current state\n\t * @returns {String} State Representation in one line  */\n\tstate.prototype._generateCondencedString = function() {\n\t\treturn  k.utils.obj.map(\n\t\t\tk.utils.obj.sortBy(this._items, function(item)\n\t\t\t{\n\t\t\t\treturn item.rule.index;\n\t\t\t}),\n\t\t\tfunction (item) {\n\t\t\t\treturn item.rule.index;\n\t\t\t}).join('-');\n\t};\n\n\t/* @function Generates an ID that identify this state from any other state\n\t * @returns {String} Generated ID  */\n\tstate.prototype._generateIdentity = function() {\n\n\t\tif (this.isAcceptanceState)\n\t\t{\n\t\t\treturn state.constants.AcceptanceStateName;\n\t\t}\n\t\telse if (!this._items.length)\n\t\t{\n\t\t\treturn _super.prototype._generateIdentity.apply(this, arguments);\n\t\t}\n\n\t\treturn k.utils.obj.reduce(\n\t\t\tk.utils.obj.sortBy(this._items, function(item)\n\t\t\t{\n\t\t\t\treturn item.rule.index;\n\t\t\t}),\n\t\t\tfunction (acc, item) {\n\t\t\t\treturn acc + item.getIdentity(); //.rule.index + '(' + item.dotLocation + ')';\n\t\t\t}, '');\n\t};\n\n\t/* @function Returns a copy the items contained in the current state\n\t * @returns {[ItemRule]} Array of cloned item rules  */\n\tstate.prototype.getItems = function() {\n\t\treturn k.utils.obj.map(this._items, function(item) {\n\t\t\treturn item.clone();\n\t\t});\n\t};\n\n\t/* @function Returns an orignal item rule based on its id.\n\t\tThis method is intended to be use as READ-ONLY, editing the returned items will affect the state and the rest of the automata at with this state belongs to.\n\t * @returns {[ItemRule]} Array of current item rules  */\n\tstate.prototype.getOriginalItems = function() {\n\t\treturn this._items;\n\t};\n\n\t/* @function Returns an orignal item rule based on its id.\n\t\tThis method is intended to be use as READ-ONLY, editing the returned items will affect the state and the rest of the automata at with this state belongs to.\n\t * @returns {ItemRule} Item rule corresponding to the id passed in if present or null otherwise  */\n\tstate.prototype.getOriginalItemById = function(id) {\n\t\treturn this._registerItems[id];\n\t};\n\n\t/** @function Get the list of all supported symbol which are valid to generata transition from the current state.\n\t * @returns {[Object]} Array of object of the form: {symbol, items} where items have an array of item rules  */\n\tstate.prototype.getSupportedTransitionSymbols = function() {\n\t\tvar itemsAux = {},\n\t\t\tresult = [],\n\t\t\tsymbol;\n\n\t\tk.utils.obj.each(this._items, function (item)\n\t\t{\n\t\t\tsymbol = item.getCurrentSymbol();\n\t\t\tif (symbol)\n\t\t\t{\n\t\t\t\tif (itemsAux[symbol.name]) {\n\t\t\t\t\titemsAux[symbol.name].push(item);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\titemsAux[symbol.name] = [item];\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tsymbol: symbol,\n\t\t\t\t\t\titems: itemsAux[symbol.name]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t};\n\n\t/* @function Responsible of new transitions. We override this method to use the correct variable names and be more meanful\n\t * @param {Symbol} symbol Symbol use to make the transition, like the name of the transition\n\t * @param {State} state Destination state arrived when moving with the specified tranisiotn\n\t * @returns {Object} Transition object  */\n\tstate.prototype._generateNewTransition = function (symbol, state) {\n\t\treturn {\n\t\t\tsymbol: symbol,\n\t\t\tstate: state\n\t\t};\n\t};\n\n\t/* @function Returns the list of item rules contained in the current state that are reduce item rules.\n\t * @returns {[ItemRule]} Recude Item Rules  */\n\tstate.prototype.getRecudeItems = function () {\n\t\treturn k.utils.obj.filter(this._items, function (item) {\n\t\t\treturn item.isReduce();\n\t\t});\n\t};\n\n\treturn state;\n})(k.data.Node);","/* Automata\n* @class\n* @classdesc This class reprensent an automata, whith all its state and transitions */\nk.data.Automata = (function() {\n\t'use strict';\n\t/*\n\t* Automata Constructor\n\t*\n\t* @constructor\n\t* @param {[State]} options.states Array of initial states\n\t* @param {State} options.initialState Initial state of the automata.\n\t* @param {Bool} options.hasLookAhead Boolean value used to indicate if the items if the state use or not look ahead.\n\t*/\n\tvar automata = function (options)\n\t{\n\t\tthis.options = options;\n\n\t\tk.utils.obj.defineProperty(this, 'states');\n\t\tk.utils.obj.defineProperty(this, 'initialState');\n\t\t//Determines if the current autamata has or not lookAhead. This is set by the automata Generator\n\t\tk.utils.obj.defineProperty(this, 'hasLookAhead');\n\n\n\t\tk.utils.obj.defineProperty(this, '_index');\n\t\tk.utils.obj.defineProperty(this, '_unprocessedStates');\n\t\tk.utils.obj.defineProperty(this, '_registerStates');\n\n\t\tthis.states = options.states || [];\n\t\tthis._unprocessedStates = [];\n\t\tthis._index = 0; //Index used to traversal the states of the current instance\n\t\tthis._registerStates = k.utils.obj.groupBy(this.states, function (state) {return state.getIdentity();});\n\n\t\tif (this.states.length)\n\t\t{\n\t\t\tthis._unprocessedStates = [].concat(this.states);\n\t\t}\n\t};\n\n\t/* @function Convert the current automata to its string representation\n\t* @returns {String} formatted string */\n\tautomata.prototype.toString = function ()\n\t{\n\t\treturn this.states.join('\\n');\n\t};\n\n\t/* @function Get the next unprocessed state\n\t* @returns {State} A State not processed yet if any or null otherwise */\n\tautomata.prototype.getNextState = function()\n\t{\n\t\treturn this._unprocessedStates.splice(0,1)[0];\n\t};\n\n\t/* @function Set or get the initial state.\n\t* @param {State} state If specified, set the initial state of the automata\n\t* @returns {State} In case that none state is specifed returnes the initial state previously set */\n\tautomata.prototype.initialStateAccessor = function(state)\n\t{\n\t\tif (!state) {\n\t\t\treturn this.initialState;\n\t\t}\n\t\tthis.initialState = state;\n\t};\n\n\t/* @function Add a new state into the automata controlling if it is duplicated or not. If the new state is duplicated we merge its look-ahead\n\t* @param {State} newState State to add\n\t* @returns {State} The added state, if the state is duplicated returns the already created state */\n\tautomata.prototype.addState = function(newState)\n\t{\n\t\tif (!this._registerStates[newState.getIdentity()])\n\t\t{\n\t\t\tthis._registerStates[newState.getIdentity()] = newState;\n\t\t\tthis.states.push(newState);\n\t\t\tthis._unprocessedStates.push(newState);\n\t\t}\n\t\telse if (this.hasLookAhead)\n\t\t{\n\t\t\t//When the states are the same in rules but its only difference is in its the look aheads, as a easy-to-implement LALR(1) parser, we merge this look-aheads\n\t\t\tvar currentState = this._registerStates[newState.getIdentity()],\n\t\t\t\tcurrentStateHasChange = false;\n\n\t\t\tk.utils.obj.each(currentState.getOriginalItems(), function (originalItemRule)\n\t\t\t{\n\t\t\t\tvar newItemRule = newState.getOriginalItemById(originalItemRule.getIdentity()),\n\t\t\t\t\toriginalItemRuleLookAheadLength = originalItemRule.lookAhead.length;\n\n\t\t\t\toriginalItemRule.lookAhead = k.utils.obj.uniq(originalItemRule.lookAhead.concat(newItemRule.lookAhead), function (item) { return item.name;});\n\n\t\t\t\tif (!currentStateHasChange && originalItemRuleLookAheadLength !== originalItemRule.lookAhead.length)\n\t\t\t\t{\n\t\t\t\t\tcurrentStateHasChange = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (currentStateHasChange)\n\t\t\t{\n\t\t\t\tvar isCurrentStateAlreadyUnProcessed = k.utils.obj.find(this._unprocessedStates, function (unprocessedState)\n\t\t\t\t{\n\t\t\t\t\treturn currentState.getIdentity() === unprocessedState.getIdentity();\n\t\t\t\t});\n\n\t\t\t\tif (!isCurrentStateAlreadyUnProcessed)\n\t\t\t\t{\n\t\t\t\t\tthis._unprocessedStates.push(currentState);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this._registerStates[newState.getIdentity()];\n\t};\n\n\treturn automata;\n})();\n","/*global toString: true*/\n//TODO: Implement a REAL lexer. This one is just a temporal one!\n\n/* Lexer\n* @class\n* @classdesc This class scan an input stream and convert it to an token input */\nk.lexer.Lexer = (function() {\n\t'use strict';\n\n\tvar defaultOptions = {\n\t\tnotIgnoreSpaces : false\n\t};\n\n\t/*\n\t* Initialize a new Lexer\n\t*\n\t* @constructor\n\t* @param {Grammar} options.grammar Grammar used to control the scan process\n\t* @param {String} options.stream Input Stream (Generally a String)\n\t* @param {Boolean} options.notIgnoreSpaces If true spaces are not ignored. False by default.\n\t*\tIMPORTANT: If the grammar has empty rules (A --> <EMPTY>) ignoring spaces will make that the lexer returns EOF instead of EMPTY at the end of the string ('').\n\t* @param {Boolean} options.notIgnoreNewLines If true enters are not ignored. False by default.\n\t*\tIMPORTANT: If the grammar has empty rules (A --> <EMPTY>) ignoring new lines will make that the lexer returns EOF instead of EMPTY at the end of the string ('').\n\t*/\n\tvar lexer = function (options)\n\t{\n\t\tthis.options = k.utils.obj.extendInNew(defaultOptions, options || {});\n\n\t\tk.utils.obj.defineProperty(this, 'grammar');\n\t\tk.utils.obj.defineProperty(this, 'stream'); //Specified input stream\n\t\tk.utils.obj.defineProperty(this, 'inputStream'); // Post-Processed input stream\n\t\tk.utils.obj.defineProperty(this, 'notIgnoreSpaces');\n\t\tk.utils.obj.defineProperty(this, 'notIgnoreNewLines');\n\n\t\tthis.setStream(this.stream);\n\t};\n\n\t/* @function Set the input string stream\n\t* @param {String} stream Input string to be processed\n\t* @returns {Void} */\n\tlexer.prototype.setStream = function (stream)\n\t{\n\t\tthis.inputStream = this.stream = stream;\n\t\tthis._clearStream();\n\t};\n\n\t/* @function Process the current string stream to clear ignored spaced and enters, leaving the resulted string in the same inputStream\n\t* @returns {Void} */\n\tlexer.prototype._clearStream = function ()\n\t{\n\t\tif (k.utils.obj.isUndefined(this.inputStream))\n\t\t{\n\t\t\tthis.inputStream = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!this.notIgnoreSpaces || !this.notIgnoreNewLines)\n\t\t\t{\n\t\t\t\tif (!this.notIgnoreSpaces && !this.notIgnoreNewLines)\n\t\t\t\t{\n\t\t\t\t\tthis.inputStream = k.utils.str.fullLtrim(this.inputStream);\n\t\t\t\t}\n\t\t\t\telse if (!this.notIgnoreSpaces)\n\t\t\t\t{\n\t\t\t\t\tthis.inputStream = k.utils.str.ltrim(this.inputStream);\n\t\t\t\t}\n\t\t\t\telse if (!this.notIgnoreNewLines)\n\t\t\t\t{\n\t\t\t\t\tthis.inputStream = k.utils.str.ltrimBreaks(this.inputStream);\n\t\t\t\t}\n\n\t\t\t\t// if ignoring spaces and the input string is empty, set the input as finished\n\t\t\t\tif (this.inputStream === '')\n\t\t\t\t{\n\t\t\t\t\tthis.inputStream = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/* @function Get a generic result in case of error, when the lexer cannnot match any terminal in the input\n\t* @returns {Object} An object representing the the mis of any match (error)  */\n\tlexer.prototype._getErrorResult = function()\n\t{\n\t\treturn {\n\t\t\t\tlength: -1,\n\t\t\t\tstring: this.inputStream,\n\t\t\t\tERROR: 'NOT MATCHING FOUND'\n\t\t\t};\n\t};\n\n\t/* @function Searh for the next token the in the current inputStream.\n\t* IMPORTANT: In order to call this function the inputStream should not be null neither the empty string.\n\t* @returns {Object} An object representing the current finded token.\n\t* {Number} result.length Length of the matched string\n\t* {String} result.string String matched\n\t* {Terminal} result.terminal matching terminal */\n\tlexer.prototype._searchNextToken = function ()\n\t{\n\t\tvar result = {\n\t\t\t\tlength: -1\n\t\t\t},\n\t\t\tterminals = this.grammar.terminals,\n\t\t\tbody;\n\n\t\tfor (var i = 0; i < terminals.length; i++)\n\t\t{\n\t\t\tbody = terminals[i].body;\n\t\t\t//If it's reg exp and match (this.inputStream.search(body) returns the index of matching which evals to false so !)\n\t\t\tif (body instanceof RegExp && !this.inputStream.search(body))\n\t\t\t{\n\t\t\t\tvar match = body.exec(this.inputStream)[0];\n\t\t\t\tif (result.length < match.length)\n\t\t\t\t{\n\t\t\t\t\tresult = {\n\t\t\t\t\t\tlength: match.length,\n\t\t\t\t\t\tstring: match,\n\t\t\t\t\t\tterminal: terminals[i]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//if it is a string check if they are the same\n\t\t\telse if (k.utils.obj.isString(body) && k.utils.str.startsWith(this.inputStream, body) && result.length < body.length)\n\t\t\t{\n\t\t\t\tresult = {\n\t\t\t\t\tlength: body.length,\n\t\t\t\t\tstring: body,\n\t\t\t\t\tterminal: terminals[i]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/* @function Get next input token\n\t* @returns {Object} An object representing the current finded token.\n\t* {Number} result.length Length of the matched string\n\t* {String} result.string String matched\n\t* {Terminal} result.terminal matching terminal */\n\tlexer.prototype.getNext = function ()\n\t{\n\t\tvar result = {\n\t\t\t\tlength: -1\n\t\t\t},\n\t\t\tgrammarHasEmptyRules;\n\n\t\tif (this.inputStream === null)\n\t\t{\n\t\t\tresult = {\n\t\t\t\tlength: -1,\n\t\t\t\tterminal: new k.data.Symbol({name: k.data.specialSymbol.EOF})\n\t\t\t};\n\t\t}\n\t\telse if (this.inputStream === '')\n\t\t{\n\t\t\tgrammarHasEmptyRules = grammarHasEmptyRules || k.utils.obj.find(this.grammar.rules, function (rule)\n\t\t\t\t{\n\t\t\t\t\treturn rule.tail.length === 1 && rule.tail[0].isSpecial && rule.tail[0].name === k.data.specialSymbol.EMPTY;\n\t\t\t\t});\n\n\t\t\tif (grammarHasEmptyRules)\n\t\t\t{\n\t\t\t\tresult = {\n\t\t\t\t\tlength: 0,\n\t\t\t\t\tstring: '',\n\t\t\t\t\tterminal: new k.data.Symbol({name: k.data.specialSymbol.EMPTY})\n\t\t\t\t};\n\t\t\t\tthis.inputStream = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = this._getErrorResult();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = this._searchNextToken();\n\n\t\t\tif (result.length === -1)\n\t\t\t{\n\t\t\t\t//if there is no valid match, we return the current input stream as an error\n\t\t\t\tresult = this._getErrorResult();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//If there is a match\n\t\t\t\tthis.inputStream = this.inputStream.substr(result.length);\n\t\t\t\tthis._clearStream();\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn lexer;\n})();\n","/*Enum for valid action in an action table\n* @readonly\n* @enum {String}\n*/\nvar tableAction = k.parser.tableAction = {\n\tSHIFT: 'SHIFT',\n\tREDUCE: 'REDUCE',\n\tERROR: 'ERROR',\n\tACCEPT: 'ACCEPT'\n};\n\n/* Abstract Base Automata Generator\n* @class\n* @classdesc This is the base class for all LR automatas generator. The idea is simplify the autamata creation process */\nk.parser.AutomataLRGeneratorBase = (function() {\n\t'use strict';\n\t/*\n\t* Initialize a new Automaton Generator\n\t*\n\t* @constructor\n\t* @param {Grammar} options.grammar Grammar used to generate the automata\n\t*/\n\tvar automataLRGeneratorBase = function (options)\n\t{\n\t\tthis.options = options;\n\n\t\tk.utils.obj.defineProperty(this, 'grammar');\n\n\t\tif (!(this.grammar instanceof k.data.Grammar))\n\t\t{\n\t\t\tthrow new Error('In order to create a new Automata Generator please provide a grammar!');\n\t\t}\n\t};\n\n\t/* @function Expands a state adding in it the full list of require items (item rules)\n\t* @param {State} currentState State that will be expanded\n\t* @returns {State} The full state with all its require items */\n\tautomataLRGeneratorBase.prototype.expandItem = function (currentState)\n\t{\n\t\t// The inital rule is first added and then this method is called\n\t\tvar currentSymbol,\n\t\t\tcurrentItem = currentState.getNextItem();\n\n\t\twhile (currentItem) {\n\t\t\tcurrentSymbol = currentItem.getCurrentSymbol();\n\n\t\t\tif (currentSymbol instanceof k.data.NonTerminal)\n\t\t\t{\n\t\t\t\tcurrentState.addItems(this._newItemRulesForStateExpansion(currentItem, currentSymbol), this._getExpansionItemNewItemsOptions());\n\t\t\t}\n\n\t\t\tcurrentItem = currentState.getNextItem();\n\t\t}\n\n\t\treturn currentState;\n\t};\n\n\t/* @function Generate the options used to add item rules into the states when thy are being expanded\n\t* @returns {Object} An object specifying the options used by the state.addItems method to include methods */\n\tautomataLRGeneratorBase.prototype._getExpansionItemNewItemsOptions = function ()\n\t{\n\t\treturn {};\n\t};\n\n\t/* @function Generate the list of item rules that can be getted from a state when expanding it in the automata creation prcoess.\n\t* This method is intended to be overwritten!.\n\t* @param {ItemRule} currentItem The current item rule from which the new item rule are being generated.\n\t* @param {Symbol} currentSymbol Is the symbol used to find new item rules.\n\t* @returns {[ItemRule]} Array of item rule ready to be part of the current processing state */\n\tautomataLRGeneratorBase.prototype._newItemRulesForStateExpansion = function (currentItem, currentSymbol)\n\t{};\n\n\t/* @function Generate the requested automata\n\t* This method allows that sub-clases override it and have already almost all the implementation done in the method _generateAutomata()\n\t* @param {Boolean} options.notValidate Indicate if the resulting automata should be validated for the current lookAhead or not. False by default (DO validate the automata).\n\t* @param {[ConflicResolver]} options.conflictResolvers ORDERED List of conflicts resolvers used in case of conflicts in the state.\n\t* @returns {Automata} The corresponding automata for the specified grammar */\n\tautomataLRGeneratorBase.prototype.generateAutomata = function (options)\n\t{\n\t\tvar defaultAutomataGenerationOptions = {\n\t\t\t\tnotValidate: false,\n\t\t\t\tconflictResolvers: []\n\t\t\t};\n\n\t\toptions = k.utils.obj.extendInNew(defaultAutomataGenerationOptions, options || {});\n\n\t\tvar automata = this._generateAutomata();\n\n\t\tif (!options.notValidate && !this.isAutomataValid(automata, options))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn automata;\n\t};\n\n\t/* @function Validates an automata based on the current generator type (consider or not look-ahead)\n\t* @param {Autamata} automata Automata instances to be validated\n\t* @param {[ConflicResolver]} options.conflictResolvers ORDERED List of conflicts resolvers used in case of conflicts in the state.\n\t* @returns {Boolean} true in case the automata is valid, false otherwise */\n\tautomataLRGeneratorBase.prototype.isAutomataValid = function (automata, options)\n\t{\n\t\tvar defaultValidationOptions = {\n\t\t\tautomata: automata\n\t\t};\n\n\t\toptions = k.utils.obj.extend(defaultValidationOptions, options || {});\n\n\t\treturn !k.utils.obj.any(automata.states, function (state)\n\t\t{\n\t\t\treturn !this.isStateValid(state, options);\n\t\t}, this);\n\t};\n\n\t/* @function Determine if the indicated state is valid or not.\n\t* This method is intended to be overwritten!.\n\t* @param {State} state State to validate\n\t* @param {Boolean} options.considerLookAhead Indicate if the state should take into account look ahead to validate. Default: false\n\t* @param {Automata} options.automata Optional automata instance used to pass to the conflict resolver in case there are conflict and resolvers.\n\t* @returns {Boolean} true if the state is valid (invalid), false otherwise (inconsistent) */\n\tautomataLRGeneratorBase.prototype.isStateValid = function (state, options)\n\t{\n\t};\n\n\t/* @function Generate the conflict resolvers list use to solve any possible conflict when validating the automata and when creating the Action table.\n\t* @returns {Automata} The corresponding automata for the specified grammar */\n\tautomataLRGeneratorBase.prototype._getConflictResolvers = function ()\n\t{\n\t};\n\n\t/* @function Actually Generate an automata\n\t* @returns {Automata} The corresponding automata for the specified grammar */\n\tautomataLRGeneratorBase.prototype._generateAutomata = function()\n\t{\n\t\tvar initialState = new k.data.State({\n\t\t\t\titems: this._getInitialStateItemRules()\n\t\t\t}),\n\t\t\tautomata = new k.data.Automata(this._getNewAutomataOptions(initialState));\n\n\t\tautomata.initialStateAccessor(initialState);\n\t\tthis._expandAutomata(automata);\n\t\treturn automata;\n\t};\n\n\t/* @function Generate the construction object used to initialize the new automata\n\t* @param {State} initialState State that only contains the items rules from the start symbol of the grammar. This is the initial state before being expanded.\n\t* @returns {Object} Object containing all the options used to create the new automata */\n\tautomataLRGeneratorBase.prototype._getNewAutomataOptions = function (initialState)\n\t{\n\t\treturn {\n\t\t\t\tstates: [this.expandItem(initialState)]\n\t\t\t};\n\t};\n\n\t/* @function Returns the initial list of item rules that will take part in the initial state of the automata. This can differ if the automata has or not lookahead\n\t* @returns {[ItemRule]} The initial list of item rule. */\n\tautomataLRGeneratorBase.prototype._getInitialStateItemRules = function ()\n\t{};\n\n\t/* @function Internal method which resive an inital automata with only it inital state and generate a full automata\n\t* @param {Automata} automata Automatma to be expanded\n\t* @returns {Automata} A full automata */\n\tautomataLRGeneratorBase.prototype._expandAutomata = function(automata)\n\t{\n\t\tvar currentState = automata.getNextState();\n\n\t\twhile (currentState) {\n\n\t\t\t//Get all valid symbol from which the current state can have transitions\n\t\t\tvar supportedTransitions = currentState.getSupportedTransitionSymbols(),\n\t\t\t\taddedState, //To control duplicated states\n\t\t\t\tnewItemRules = [];\n\n\t\t\t// For each supported transicion from the current state, explore neighbours states\n\t\t\t//Warning remove to create function inside this loop\n\t\t\t/*jshint -W083 */\n\t\t\tk.utils.obj.each(supportedTransitions, function (supportedTransition)\n\t\t\t{\n\t\t\t\t// for the current new neighbour of the current state, generate the basic state with the known items\n\t\t\t\tk.utils.obj.each(supportedTransition.items, function (supportedItem)\n\t\t\t\t{\n\t\t\t\t\t// Because each item in the supported transition does NOT move the dot location when retrieved from the state, we MUST do that here\n\t\t\t\t\tnewItemRules.push(supportedItem.clone({\n\t\t\t\t\t\tdotLocationIncrement: 1\n\t\t\t\t\t}));\n\t\t\t\t});\n\n\t\t\t\tvar newState = new k.data.State({\n\t\t\t\t\titems: newItemRules\n\t\t\t\t});\n\n\t\t\t\tthis.expandItem(newState, automata);\n\n\t\t\t\t// We determien if the new state is an acceptance state, if it has only the augmented rule in reduce state.\n\t\t\t\tnewState.isAcceptanceState = !!(newState.getOriginalItems().length === 1 && newState.getOriginalItems()[0].rule.name === k.data.Grammar.constants.AugmentedRuleName && newState.getOriginalItems()[0].dotLocation === 2);\n\n\t\t\t\t// Add state controlling duplicated ones\n\t\t\t\taddedState = automata.addState(newState);\n\n\t\t\t\tcurrentState.addTransition(supportedTransition.symbol, addedState);\n\n\t\t\t\tnewItemRules = [];\n\t\t\t}, this);\n\n\t\t\tcurrentState = automata.getNextState();\n\t\t}\n\t};\n\n\t/* @function Given an automata returnes its GOTO Table. The table is represented by an object where each state is a property (row) and each possible symbol is a property of the previous object (column)\n\t* Sample: table[<state>][<symbol>] = [undefined = error|<state id - string>]\n\t* @param {Automata} automata Automatma used as a base of the calculation\n\t* @returns {Object} A GOTO Table */\n\tautomataLRGeneratorBase.prototype.generateGOTOTable = function(automata)\n\t{\n\t\tvar table = {};\n\n\t\tk.utils.obj.each(automata.states, function (state)\n\t\t{\n\t\t\ttable[state.getIdentity()] = {};\n\n\t\t\tk.utils.obj.each(state.transitions, function (transition) {\n\t\t\t\ttable[state.getIdentity()][transition.symbol.toString()] = transition.state;\n\t\t\t});\n\t\t});\n\n\t\treturn table;\n\t};\n\n\t/* @function Given an automata returnes its ACTION Table.\n\t* The intend of this method is to be overwriten by each son class\n\t* @param {Automata} automata Automatma used as a base of the calculation.\n\t* @param {Boolean} options.ignoreErrors Indicate that when a state is in an error that cannot be resolver, continue the execution anyway.\n\t* @param {Boolean} options.conflictResolvers List of resolver in case of conflic in any state.\n\t* @returns {Function} Function that given the a state id and a lookAhead returns the action to take */\n\tautomataLRGeneratorBase.prototype.generateACTIONTable = function (automata, options)\n\t{};\n\n\treturn automataLRGeneratorBase;\n})();\n","/* Automata Generator\n* @class\n* @classdesc This class is reponsible for given a grammar create a new LR(0) automata */\nk.parser.AutomataLR0Generator = (function(_super) {\n\t'use strict';\n\t/* jshint latedef:false */\n\tk.utils.obj.inherit(automataLR0Generator, _super);\n\n\t/*\n\t* Initialize a new Automaton Generator\n\t*\n\t* @constructor\n\t* @param {Grammar} options.grammar Grammar used to generate the automata\n\t*/\n\tfunction automataLR0Generator (options)\n\t{\n\t\t_super.apply(this, arguments);\n\t}\n\n\t/* @function Override super method to return the list of item rules that has as its head the current symbol, without taking into account the lookAhead\n\t* @param {ItemRule} currentItem The current item rule from which the new item rule are being generated.\n\t* @param {Symbol} currentSymbol Is the symbol used to find new item rules.\n\t* @returns {[ItemRule]} Array of item rule ready to be part of the current processing state */\n\tautomataLR0Generator.prototype._newItemRulesForStateExpansion = function (currentItem, currentSymbol)\n\t{\n\t\treturn k.data.ItemRule.newFromRules(this.grammar.getRulesFromNonTerminal(currentSymbol));\n\t};\n\n\t/* @function Generate the construction object used to initialize the new automata. Override the super method to indicate that te automata should NOT use lookahead\n\t* @param {State} initialState State that only contains the items rules from the start symbol of the grammar. This is the initial state before being expanded.\n\t* @returns {Object} Object containing all the options used to create the new automata */\n\tautomataLR0Generator.prototype._getNewAutomataOptions = function ()\n\t{\n\t\tvar result = _super.prototype._getNewAutomataOptions.apply(this, arguments);\n\t\tresult.hasLookAhead = false;\n\n\t\treturn result;\n\t};\n\n\t/* @function Override super method to return the list of item rules that has as its head the start symbol of the grammar\n\t* @returns {[ItemRule]} The initial list of item rule. */\n\tautomataLR0Generator.prototype._getInitialStateItemRules = function ()\n\t{\n\t\treturn \t[new k.data.ItemRule({\n\t\t\t\t\trule: this.grammar.getRulesFromNonTerminal(this.grammar.startSymbol)[0],\n\t\t\t\t\tlookAhead: []\n\t\t\t\t})];\n\t};\n\n\t/* @function Given an automata returnes its ACTION Table.\n\t* @param {Automata} automata Automatma used as a base of the calculation\n\t* @returns {Function} Function that given the a state id and a lookAhead returns the action to take */\n\tautomataLR0Generator.prototype.generateACTIONTable = function (automata)\n\t{\n\t\tvar table = {};\n\n\t\tk.utils.obj.each(automata.states, function(state)\n\t\t{\n\t\t\tvar stateItems = state.getItems();\n\n\t\t\t// If it is a REDUCE state\n\t\t\tif (stateItems.length === 1 && stateItems[0].dotLocation === (stateItems[0].rule.tail.length))\n\t\t\t{\n\t\t\t\t// S'--> S#*\n\t\t\t\tif (state.isAcceptanceState) {\n\t\t\t\t\t table[state.getIdentity()] = {\n\t\t\t\t\t\taction: k.parser.tableAction.ACCEPT,\n\t\t\t\t\t\trule: stateItems[0].rule\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttable[state.getIdentity()] = {\n\t\t\t\t\t\taction: k.parser.tableAction.REDUCE,\n\t\t\t\t\t\trule: stateItems[0].rule\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t// SHIFT state\n\t\t\t} else {\n\t\t\t\ttable[state.getIdentity()] = {\n\t\t\t\t\taction: k.parser.tableAction.SHIFT\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\n\t\treturn (function (actionTable) {\n\t\t\treturn function (currentStateId, look_ahead)\n\t\t\t{\n\t\t\t\treturn actionTable[currentStateId] || {\n\t\t\t\t\taction: k.parser.tableAction.ERROR\n\t\t\t\t};\n\t\t\t};\n\t\t})(table);\n\t};\n\n\t/* @function  Override super method to determine if the indicated state is valid or not.\n\t* @param {State} state State to validate\n\t* @param {Boolean} options.considerLookAhead Indicate if the state should take into account look ahead to validate. Default: false\n\t* @param {Automata} options.automata Optional automata instance used to pass to the conflict resolver in case there are conflict and resolvers.\n\t* @returns {Boolean} true if the state is valid (invalid), false otherwise (inconsistent) */\n\tautomataLR0Generator.prototype.isStateValid = function (state, options)\n\t{\n\t\t//NOTE: Important! When usign this method the current implementation DOES NOT USE RESOLVERS IN THIS CASE! it just return false if invalid\n\t\t//TODO IMPLEMENT IT\n\t\toptions = k.utils.obj.isObject(options) ? options : {};\n\t\toptions.conflictResolvers = options.conflictResolvers || [];\n\n\t\tvar reduceItems = state.getRecudeItems();\n\n\t\treturn !(reduceItems.length !== state.getOriginalItems().length && reduceItems.length > 0 || reduceItems.length > 1);\n\t};\n\n\treturn automataLR0Generator;\n})(k.parser.AutomataLRGeneratorBase);\n","/* Automata Generator\n* @class\n* @classdesc This class is reponsible for given a grammar create a new LR(0) automata */\nk.parser.AutomataLALR1Generator = (function(_super)\n{\n\t'use strict';\n\t/* jshint latedef:false */\n\tk.utils.obj.inherit(automataLALR1Generator, _super);\n\n\t/*\n\t* Initialize a new Automaton Generator\n\t*\n\t* @constructor\n\t* @param {Grammar} options.grammar Grammar used to generate the automata\n\t*/\n\tfunction automataLALR1Generator (options)\n\t{\n\t\t_super.apply(this, arguments);\n\t}\n\n\t/* @function Override super method to return the list of item rules that has as its head the current symbol, TAKING into account the lookAhead\n\t* @param {ItemRule} currentItem The current item rule from which the new item rule are being generated.\n\t* @param {Symbol} currentSymbol Is the symbol used to find new item rules.\n\t* @returns {[ItemRule]} Array of item rule ready to be part of the current processing state */\n\tautomataLALR1Generator.prototype._newItemRulesForStateExpansion = function (currentItem, currentSymbol)\n\t{\n\t\tvar lookAhead = this._getFirstSet(currentItem);\n\t\treturn k.data.ItemRule.newFromRules(this.grammar.getRulesFromNonTerminal(currentSymbol), lookAhead);\n\t};\n\n\t// /* @function Override super method to return the object require to indicate that new item rules added into a state should take into account the lookAhead\n\t// * @returns {Object} Object used by State.addItemRules indicating to DO use lookAhead to merge new items */\n\t// automataLALR1Generator.prototype._getExpansionItemNewItemsOptions = function ()\n\t// {\n\t// \treturn {\n\t// \t\thasLookAhead: true\n\t// \t};\n\t// };\n\n\t/* @function Gets the array of look-ahead for the particular item rule taking into account the dot location fo the specified item rule.\n\t* @param {ItemRule} itemRule Item rule to find FIRST Set\n\t* @returns {[Terminals]} First set for specified look ahead */\n\tautomataLALR1Generator.prototype._getFirstSet = function (itemRule)\n\t{\n\t\tvar symbolsToTraverse = itemRule.rule.tail.slice(itemRule.dotLocation + 1),\n\t\t\trequestedFirstSet = [];\n\n\t\tsymbolsToTraverse = symbolsToTraverse.concat(itemRule.lookAhead);\n\n\t\tk.utils.obj.find(symbolsToTraverse, function (symbolTraversed)\n\t\t{\n\t\t\tif (symbolTraversed instanceof k.data.NonTerminal)\n\t\t\t{\n\t\t\t\trequestedFirstSet = requestedFirstSet.concat(this.grammar.firstSetsByHeader[symbolTraversed.name]);\n\t\t\t\trequestedFirstSet = k.utils.obj.uniq(requestedFirstSet, false, function (item) {return item.name;});\n\t\t\t\treturn !symbolTraversed.isNullable;\n\t\t\t}\n\t\t\telse if (symbolTraversed instanceof k.data.Terminal)\n\t\t\t{\n\t\t\t\trequestedFirstSet.push(symbolTraversed);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (symbolTraversed.isSpecial && symbolTraversed.name === k.data.specialSymbol.EOF)\n\t\t\t{\n\t\t\t\trequestedFirstSet.push(symbolTraversed);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Error('Invalid Item Rule. Impossible calculate first set. Item Rule: ' + itemRule.toString());\n\t\t\t}\n\n\t\t}, this);\n\n\t\treturn requestedFirstSet;\n\t};\n\n\t/* @function Generate the construction object used to initialize the new automata. Override the super method to indicate that te automata should DO use lookahead\n\t* @param {State} initialState State that only contains the items rules from the start symbol of the grammar. This is the initial state before being expanded.\n\t* @returns {Object} Object containing all the options used to create the new automata */\n\tautomataLALR1Generator.prototype._getNewAutomataOptions = function ()\n\t{\n\t\tvar result = _super.prototype._getNewAutomataOptions.apply(this, arguments);\n\t\tresult.hasLookAhead = true;\n\n\t\treturn result;\n\t};\n\n\t/* @function Override super method to return the list of item rules that has as its head the start symbol of the grammar, TAKING into account the lookAhead\n\t* @returns {[ItemRule]} The initial list of item rule. */\n\tautomataLALR1Generator.prototype._getInitialStateItemRules = function ()\n\t{\n\t\treturn [new k.data.ItemRule({\n\t\t\t\t\trule: this.grammar.getRulesFromNonTerminal(this.grammar.startSymbol)[0],\n\t\t\t\t\tlookAhead: [new k.data.Symbol({name: k.data.specialSymbol.EOF, isSpecial: true})]\n\t\t\t\t})];\n\t};\n\n\t/* @function Given an automata returnes its ACTION Table.\n\t* @param {Automata} automata Automatma used as a base of the calculation\n\t* @returns {Function} Function that given the a state id and a lookAhead returns the action to take */\n\tautomataLALR1Generator.prototype.generateACTIONTable = function (automata, options)\n\t{\n\t\tvar table = {};\n\n\t\tk.utils.obj.each(automata.states, function (state)\n\t\t{\n\t\t\ttable[state.getIdentity()] = {};\n\n\t\t\tif (state.isAcceptanceState)\n\t\t\t{\n\t\t\t\ttable[state.getIdentity()][k.data.specialSymbol.EOF] = {\n\t\t\t\t\taction: k.parser.tableAction.ACCEPT,\n\t\t\t\t\trule: state.getOriginalItems()[0].rule //As we augment the grammar in the acceptance state is should be only one rule, the augmented rule, for that reason is the 0\n\t\t\t\t};\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar defaultActionTableStateOptions = {\n\t\t\t\t\tignoreErrors: false,\n\t\t\t\t\tconsiderLookAhead: true\n\t\t\t\t};\n\t\t\t\toptions = k.utils.obj.extendInNew(defaultActionTableStateOptions, options || {});\n\n\t\t\t\tvar stateItems = this.getShiftReduceItemRuleFromState(state, options);\n\n\t\t\t\tif (!stateItems)\n\t\t\t\t{\n\t\t\t\t\tthrow new Error('Impossible to generate Action Table. The following state is invalid. State: ' + state.getIdentity());\n\t\t\t\t}\n\n\n\t\t\t\t//Shift Items\n\t\t\t\tk.utils.obj.each(stateItems.shiftItems, function (shiftItem)\n\t\t\t\t{\n\t\t\t\t\ttable[state.getIdentity()][shiftItem.getCurrentSymbol().name] = {\n\t\t\t\t\t\taction: k.parser.tableAction.SHIFT\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\t//Reduce Items\n\t\t\t\t//IMPORTANT: At this point the automata MUST be already validated, ensuring us that the lookAhead sets ARE DISJOINT\n\t\t\t\tk.utils.obj.each(stateItems.reduceItems, function (reduceItemRule)\n\t\t\t\t{\n\t\t\t\t\tk.utils.obj.each(reduceItemRule.lookAhead, function (reduceSymbol)\n\t\t\t\t\t{\n\t\t\t\t\t\ttable[state.getIdentity()][reduceSymbol.name] = {\n\t\t\t\t\t\t\taction: k.parser.tableAction.REDUCE,\n\t\t\t\t\t\t\trule: reduceItemRule.rule\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}, this);\n\n\n\t\treturn (function (actionTable)\n\t\t{\n\t\t\treturn function (currentStateId, look_ahead)\n\t\t\t{\n\t\t\t\treturn (actionTable[currentStateId] && look_ahead && look_ahead.name && actionTable[currentStateId][look_ahead.name] ) ||\n\t\t\t\t\t{\n\t\t\t\t\t\taction: k.parser.tableAction.ERROR\n\t\t\t\t\t};\n\n\t\t\t};\n\t\t})(table);\n\t};\n\n\t/* @function  Override super method to determine if the current state is valid or not.\n\t * @param {Boolean} options.considerLookAhead Indicate if the state should take into account look ahead to validate. Default: false\n\t * @param {Automata} options.automata Optional automata instance used to pass to the conflict resolver in case there are conflict and resolvers.\n\t * @param {[ConflictResolver]} options.conflictResolvers List of conflict resolvers used to resolve possible conflict at the current state.\n\t * @returns {Boolean} true if the state is valid (invalid), false otherwise (inconsistent) */\n\tautomataLALR1Generator.prototype.isStateValid = function (state, options)\n\t{\n\t\toptions = k.utils.obj.isObject(options) ? options : {};\n\t\toptions.conflictResolvers = options.conflictResolvers || [];\n\n\t\tvar reduceItems = state.getRecudeItems(),\n\t\t\tisTheConflictResolvableWithResolvers = false;\n\n\t\tvar shiftItems = k.utils.obj.filter(state.getOriginalItems(), function (item)\n\t\t\t{\n\t\t\t\treturn !item.isReduce();\n\t\t\t});\n\n\t\t//Check for SHIFT/REDUCE Conflicts\n\t\tif (shiftItems.length && reduceItems.length)\n\t\t{\n\t\t\tvar shiftReduceResolvers = k.utils.obj.sortBy(k.utils.obj.filter(options.conflictResolvers, function (resolver)\n\t\t\t{\n\t\t\t\treturn resolver.type === k.parser.conflictResolverType.STATE_SHIFTREDUCE;\n\t\t\t}), 'order');\n\n\t\t\t//Generla Idea: For each shift item rule validate that the shift symbol is not in any lookAhead symbol of any reduce rule\n\n\t\t\t//For each shift item\n\t\t\tvar isAnyShiftReduceConflict = k.utils.obj.any(shiftItems, function (shiftItem)\n\t\t\t{\n\t\t\t\t//get the shift symbol\n\t\t\t\tvar shiftSymbol = shiftItem.getCurrentSymbol();\n\n\t\t\t\t//find among all reduce items\n\t\t\t\treturn k.utils.obj.find(reduceItems, function (reduceItem)\n\t\t\t\t{\n\t\t\t\t\t//if the shift symbol is in any reduce item rule's lookAhead set.\n\n\t\t\t\t\tvar isShiftSymbolInReduceLookAhead = k.utils.obj.find(reduceItem.lookAhead, function (lookAheadSymbol) { return lookAheadSymbol.name === shiftSymbol.name;});\n\t\t\t\t\tif (isShiftSymbolInReduceLookAhead)\n\t\t\t\t\t{\n\t\t\t\t\t\tisTheConflictResolvableWithResolvers = k.utils.obj.find(shiftReduceResolvers, function (resolver)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn resolver.resolve(options.automata, state, shiftItem, reduceItem);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !isTheConflictResolvableWithResolvers;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (isAnyShiftReduceConflict)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t//Check for REDUCE/REDUCE Conflicts\n\t\tif (reduceItems.length > 1)\n\t\t{\n\t\t\tvar reduceReduceResolvers = k.utils.obj.sortBy(k.utils.obj.filter(options.conflictResolvers, function (resolver)\n\t\t\t\t{\n\t\t\t\t\treturn resolver.type === k.parser.conflictResolverType.STATE_REDUCEREDUCE;\n\t\t\t\t}), 'order');\n\n\t\t\t//General Idea: For each reduce rule, validate that its look Ahead set is disjoin with the rest of the reduce rule\n\n\t\t\t//for each reduce rule\n\t\t\tvar isAnyReduceReduceConflict = k.utils.obj.any(reduceItems, function (reduceItemSelected)\n\t\t\t{\n\t\t\t\t//compare it with each of the other reduce rules\n\t\t\t\treturn k.utils.obj.find(reduceItems, function (reduceItemInspected)\n\t\t\t\t{\n\t\t\t\t\tif (reduceItemInspected.getIdentity() === reduceItemSelected.getIdentity())\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t//and for each look ahead symbol of the first reduce rule, validate the it is not present in any other look Ahead\n\t\t\t\t\tvar isLookAheadSymbolInOtherLookAheadSet = k.utils.obj.find(reduceItemSelected.lookAhead, function (lookAheadSelected)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn k.utils.obj.find(reduceItemInspected.lookAhead, function (lookAheadSymbol) { return lookAheadSymbol.name === lookAheadSelected.name;});\n\t\t\t\t\t});\n\n\t\t\t\t\tif (isLookAheadSymbolInOtherLookAheadSet)\n\t\t\t\t\t{\n\t\t\t\t\t\tisTheConflictResolvableWithResolvers = k.utils.obj.find(reduceReduceResolvers, function (resolver)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn resolver.resolve(options.automata, state, reduceItemSelected, reduceItemInspected);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !isTheConflictResolvableWithResolvers;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t});\n\n\t\t\tif (isAnyReduceReduceConflict)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\t/* @function Generates the list of shift and reduce items that take part from the passed in state. Validating at the same time that none of these items are in conflict\n\t\tor that the conflicts are solvable.\n\t * @param {State} state State to extract form each of the reduce/shift item rules\n\t * @param {Boolean} options.considerLookAhead Indicate if the state should take into account look ahead to validate. If not the state will validate and generate the result as in a LR(0). Default: false\n\t * @param {Automata} options.automata Optional automata instance used to pass to the conflict resolver in case there are conflict and resolvers.\n\t * @param {[ConflictResolver]} options.conflictResolvers List of conflict resolvers used to resolve possible conflict at the current state.\n\t * @param {Boolean} options.ignoreErrors Indicate if when facing an error (a conflict that can not be solve by any resolver) continue the execution. Default: false\n\t * @returns {Object} An object containg two properties (arrays) shiftItems and reduceItems */\n\tautomataLALR1Generator.prototype.getShiftReduceItemRuleFromState = function (state, options)\n\t{\n\t\toptions = k.utils.obj.isObject(options) ? options : {};\n\t\toptions.conflictResolvers = options.conflictResolvers || [];\n\n\t\tvar reduceItems = state.getRecudeItems(),\n\t\t\tshiftItems = k.utils.obj.filter(state.getOriginalItems(), function (item)\n\t\t\t{\n\t\t\t\treturn !item.isReduce();\n\t\t\t}),\n\t\t\tignoreErrors = !!options.ignoreErrors,\n\t\t\tresult = {shiftItems:[], reduceItems:[]},\n\t\t\tisTheConflictResolvableWithResolvers = false;\n\n\t\t//We clone the reduce item, becuase when there is a Shift/Reduce conflic and the solution is shift, we need to remove the shift symbol from the lookAhead set of the reduce item!\n\t\t//Otherwise when createion the Action table the reduce item end it up overriding the shift actions! (see automataLALRGenerator)\n\t\treduceItems = k.utils.obj.map(reduceItems, function (reduceItem)\n\t\t{\n\t\t\treturn reduceItem.clone();\n\t\t});\n\n\t\t//Process all SHIFT items & Check for SHIFT/REDUCE Conflicts\n\t\tif (shiftItems.length)\n\t\t{\n\t\t\tvar shiftReduceResolvers = k.utils.obj.sortBy(k.utils.obj.filter(options.conflictResolvers, function (resolver)\n\t\t\t{\n\t\t\t\treturn resolver.type === k.parser.conflictResolverType.STATE_SHIFTREDUCE;\n\t\t\t}), 'order');\n\n\t\t\t//Generla Idea: For each shift item rule validate that the shift symbol is not in any lookAhead symbol of any reduce rule\n\n\t\t\t//For each shift item\n\t\t\tvar isAnyShiftReduceConflict = k.utils.obj.any(shiftItems, function (shiftItem)\n\t\t\t{\n\t\t\t\t//get the shift symbol\n\t\t\t\tvar shiftSymbol = shiftItem.getCurrentSymbol();\n\n\t\t\t\t//find among all reduce items\n\t\t\t\tvar isShiftItemInConflict = k.utils.obj.find(reduceItems, function (reduceItem)\n\t\t\t\t{\n\t\t\t\t\t//if the shift symbol is in any reduce item rule's lookAhead set.\n\t\t\t\t\t//NOTE: Here we obtain the lookAhead Symbol that is in conflict, if any.\n\t\t\t\t\tvar isShiftSymbolInReduceLookAhead = k.utils.obj.find(reduceItem.lookAhead, function (lookAheadSymbol) { return lookAheadSymbol.name === shiftSymbol.name;});\n\n\t\t\t\t\t//if there is a possible shift/reduce conflict try to solve it by usign the resolvers list\n\t\t\t\t\tif (isShiftSymbolInReduceLookAhead)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar conflictSolutionFound;\n\t\t\t\t\t\tisTheConflictResolvableWithResolvers = k.utils.obj.find(shiftReduceResolvers, function (resolver)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconflictSolutionFound = resolver.resolve(options.automata, state, shiftItem, reduceItem);\n\t\t\t\t\t\t\treturn conflictSolutionFound;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t//If the conflict is resolvable, and the action to be taken is SHIFT, we remove the Shift symbol from the reduce item lookAhead, so when creating the Action table\n\t\t\t\t\t\t//that symbol wont take part of the table.\n\t\t\t\t\t\tif (isTheConflictResolvableWithResolvers && conflictSolutionFound.action === k.parser.tableAction.SHIFT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar symbolIndexToRemove = k.utils.obj.indexOf(reduceItem.lookAhead, isShiftSymbolInReduceLookAhead);\n\t\t\t\t\t\t\treduceItem.lookAhead.splice(symbolIndexToRemove,1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn !isTheConflictResolvableWithResolvers;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\tif (!isShiftItemInConflict || ignoreErrors)\n\t\t\t\t{\n\t\t\t\t\tresult.shiftItems.push(shiftItem);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t});\n\n\t\t\tif (isAnyShiftReduceConflict)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t//Process all REDUCE items & Check for REDUCE/REDUCE Conflicts\n\t\tif (reduceItems.length)\n\t\t{\n\t\t\tvar reduceReduceResolvers = k.utils.obj.sortBy(k.utils.obj.filter(options.conflictResolvers, function (resolver)\n\t\t\t\t{\n\t\t\t\t\treturn resolver.type === k.parser.conflictResolverType.STATE_REDUCEREDUCE;\n\t\t\t\t}), 'order');\n\n\t\t\t//General Idea: For each reduce rule, validate that its look Ahead set is disjoin with the rest of the reduce rule\n\n\t\t\t//for each reduce rule\n\t\t\tvar isAnyReduceReduceConflict = k.utils.obj.any(reduceItems, function (reduceItemSelected)\n\t\t\t{\n\t\t\t\t//compare it with each of the other reduce rules\n\t\t\t\tvar isReduceItemInConflict = k.utils.obj.find(reduceItems, function (reduceItemInspected)\n\t\t\t\t{\n\t\t\t\t\tif (reduceItemInspected.getIdentity() === reduceItemSelected.getIdentity())\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t//and for each look ahead symbol of the first reduce rule, validate the it is not present in any other look Ahead\n\t\t\t\t\tvar isLookAheadSymbolInOtherLookAheadSet = k.utils.obj.find(reduceItemSelected.lookAhead, function (lookAheadSelected)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn k.utils.obj.find(reduceItemInspected.lookAhead, function (lookAheadSymbol) { return lookAheadSymbol.name === lookAheadSelected.name;});\n\t\t\t\t\t});\n\n\t\t\t\t\tif (isLookAheadSymbolInOtherLookAheadSet)\n\t\t\t\t\t{\n\t\t\t\t\t\tisTheConflictResolvableWithResolvers = k.utils.obj.find(reduceReduceResolvers, function (resolver)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn resolver.resolve(options.automata, state, reduceItemSelected, reduceItemInspected);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !isTheConflictResolvableWithResolvers;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\tif (!isReduceItemInConflict || ignoreErrors)\n\t\t\t\t{\n\t\t\t\t\tresult.reduceItems.push(reduceItemSelected);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t\tif (isAnyReduceReduceConflict)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn automataLALR1Generator;\n})(k.parser.AutomataLRGeneratorBase);\n","\n/* Enum that describe valid types of conflict resolvers\n* @readonly\n* @enum {String}\n*/\nvar conflictResolverType = k.parser.conflictResolverType = {\n\tSTATE_SHIFTREDUCE: 'STATE_SHIFTREDUCE',\n\tSTATE_REDUCEREDUCE: 'STATE_REDUCEREDUCE'\n};\n\n/* State Conflict Resolver\n* @class\n* @classdesc This class is responsible for resolver conflicts at state level, for example Shift/Reduce conflicts */\nvar ConflictResolver = k.parser.ConflictResolver = (function () {\n\t'use strict';\n\t/*\n\t* Initialize a new Conflict Resolver\n\t*\n\t* @constructor\n\t* @param {String} options.name Uique name of the resolver.\n\t* @param {conflictResolverType} options.type Indicate the kind of conflict that the current resolver can handle. Default: STATE_SHIFTREDUCE\n\t* @param {Integer} options.order Numeric values used to sort the resolver and in this way take precendence at the moment of resolve a problem.\n\t\tResolvers will be sorted from lowest values to highest. Default: 9999\n\t* @param {Function} options.resolveFnc function evalutad at the time of resolve a conflict. Default: Just return false\n\t*/\n\tvar conflictResolver = function (options)\n\t{\n\t\tthis.options = options || {};\n\n\t\tk.utils.obj.defineProperty(this, 'name');\n\t\tk.utils.obj.defineProperty(this, 'type');\n\t\tk.utils.obj.defineProperty(this, 'order');\n\t\tk.utils.obj.defineProperty(this, 'resolveFnc');\n\n\t\tthis.type = this.type || conflictResolverType.STATE_SHIFTREDUCE;\n\t\tthis.order = this.order || 9999;\n\t};\n\n\t/* @function Resolve a conflict\n\t* This method main idea is that sub-clases override it and implement the real logic. By defaukt it should return false.\n\t* @param {Automata} automata Automata containing the state tothat is being validated.\n\t* @param {State} state State that contains the conflict.\n\t* @param {ItemRule} itemRule1 In case of SHIFT/REDUCE conflict is the SHIFT item rule.\n\t* @param {ItemRule} itemRule2 In case of SHIFT/REDUCE conflict is the REDUCE item rule.\n\t* @returns {Object} This meethod will return false in there is not solution for the conflict, otherwise will return an object containing the next properties:\n\t\t\taction: {tableAction} string solution, iteRule: {ItemRule} item rule that should be taken into account*/\n\tconflictResolver.prototype.resolve = function (automata, state, itemRule1, itemRule2)\n\t{\n\t\treturn  k.utils.obj.isFunction(this.resolveFnc) ? this.resolveFnc(automata, state, itemRule1, itemRule2) : false;\n\t};\n\n\t/* @function Generate the default list of resolvers. These are:\n\t\tShift/Reduce Resolver: Precendence\n\t\tShift/Reduce Resolver: Associativity\n\t* @returns {[ConflictResolver]} List of the default (wide-app) Conflict Resolvers. */\n\tconflictResolver.getDefaultResolvers = function ()\n\t{\n\t\treturn [\n\t\t\t\tnew ConflictResolver({\n\t\t\t\t\tname: 'precedence_resolver',\n\t\t\t\t\ttype: conflictResolverType.STATE_SHIFTREDUCE,\n\t\t\t\t\torder: 10,\n\t\t\t\t\tresolveFnc: function (automata, state, shiftItemRule, reduceItemRule)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!k.utils.obj.isNumber(shiftItemRule.rule.precendence) && !k.utils.obj.isNumber(reduceItemRule.rule.precendence))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//If neither of the rules define precedence, we can resolve the conflict\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshiftItemRule.rule.precendence =  k.utils.obj.isNumber(shiftItemRule.rule.precendence) ? shiftItemRule.rule.precendence : 0;\n\t\t\t\t\t\treduceItemRule.rule.precendence =  k.utils.obj.isNumber(reduceItemRule.rule.precendence) ? reduceItemRule.rule.precendence : 0;\n\n\t\t\t\t\t\tif (shiftItemRule.rule.precendence > reduceItemRule.rule.precendence)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\titemRule: shiftItemRule,\n\t\t\t\t\t\t\t\taction: k.parser.tableAction.SHIFT\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (shiftItemRule.rule.precendence < reduceItemRule.rule.precendence)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\titemRule: reduceItemRule,\n\t\t\t\t\t\t\t\taction: k.parser.tableAction.REDUCE\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false; // both rules have the same precendence\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tnew ConflictResolver({\n\t\t\t\t\tname: 'associativity_resolver',\n\t\t\t\t\ttype: conflictResolverType.STATE_SHIFTREDUCE,\n\t\t\t\t\torder: 20,\n\t\t\t\t\tresolveFnc: function (automata, state, shiftItemRule, reduceItemRule)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar shiftSymbol = shiftItemRule.getCurrentSymbol();\n\t\t\t\t\t\tif (shiftSymbol.assoc === k.data.associativity.RIGHT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\taction: k.parser.tableAction.SHIFT,\n\t\t\t\t\t\t\t\titemRule: shiftItemRule\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (shiftSymbol.assoc === k.data.associativity.LEFT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\taction: k.parser.tableAction.REDUCE,\n\t\t\t\t\t\t\t\titemRule: reduceItemRule\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t];\n\t};\n\n\treturn conflictResolver;\n})();\n","/* Parser\n* @class\n* @classdesc Parser engine reponsible for parse an entire string */\nvar Parser = k.parser.Parser = (function() {\n\t'use strict';\n\t/*\n\t* Creates an instance of a Parser\n\t*\n\t* @constructor\n\t* @param {Object} options.gotoTable The GOTO Table of the current grammar\n\t* @param {Grammar} options.grammar The grammar used to generate all the parser\n\t* @param {Function} options.actionTable Action table used to control the parsing process\n\t* @param {State} options.initialState Initial state of the automata the describe the current grammar\n\t*/\n\tvar parser = function (options) {\n\t\tthis.options = options;\n\n\t\tk.utils.obj.defineProperty(this, 'gotoTable');\n\t\tk.utils.obj.defineProperty(this, 'grammar');\n\t\tk.utils.obj.defineProperty(this, 'actionTable');\n\t\tk.utils.obj.defineProperty(this, 'initialState');\n\n\t\tk.utils.obj.defineProperty(this, 'stack');\n\t\tk.utils.obj.defineProperty(this, 'currentInput');\n\n\t\tif (!this.gotoTable) {\n\t\t\tthrow new Error('Invalid initialization values for a Parser, please provide a GOTO Table');\n\t\t}\n\n\t\tif (!this.actionTable) {\n\t\t\tthrow new Error('Invalid initialization values for a Parser, please provide a Action Table');\n\t\t}\n\n\t\tif (!this.grammar) {\n\t\t\tthrow new Error('Invalid initialization values for a Parser, please provide a Grammar');\n\t\t}\n\n\t\tif (!this.initialState) {\n\t\t\tthrow new Error('Invalid initialization values for a Parser, please provide a Initial State');\n\t\t}\n\n\t\tthis.stack = this.stack || [];\n\t};\n\n\t/* @function Parse an input\n\t* @param {Lexer} lexer The lexer which will lexically analize the input\n\t* @returns {ASTNode|false} The generated AST in case of sucess or false otherwise */\n\tparser.prototype.parse = function(lexer) {\n\t\t//TODO TEST THIS!!!\n\n\t\tvar initialStackItem = new k.data.StackItem({\n\t\t\t\tstate: this.initialState\n\t\t\t});\n\t\tthis.currentInput = lexer.getNext();\n\t\t\n\t\tif (this.currentInput.ERROR)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tthis.stack.push(initialStackItem);\n\n\t\treturn this._parse(lexer);\n\t};\n\n\t/* @function Internal method to Parse an input. This method will loop through input analizyng the Goto and Action tables\n\t* @param {Lexer} lexer The lexer which will lexically analize the input\n\t* @returns {ASTNode|false} The generated AST in case of success or false otherwise */\n\tparser.prototype._parse = function(lexer) {\n\t\tvar stateToGo,\n\t\t\tactionToDo,\n\t\t\tlastItem = this.stack[this.stack.length-1];\n\t\t\t\n\t\t/*\n\t\tBasic Functionality: \n\t\tCreate an state, ask for an action todo based on the symbol lookAhead an the current state\n\t\t\tif SHIFT, as we have already created the state we just update our current state\n\t\t\tif ERROR, finish execution\n\t\t\tif REDUCE shrink the stack, apply reduce function and update the stack based on the reduce rule\n\t\tWhen the current state is updated ask for goto action and create the new stack item based on this answer.\n\t\t*/\n\n\t\tdo {\n\t\t\t//Action\n\t\t\tactionToDo = this.actionTable(lastItem.state.getIdentity(), this.currentInput.terminal);\n\t\t\t\n\t\t\tif (actionToDo.action === k.parser.tableAction.ERROR)\n\t\t\t{\n\t\t\t\t//TODO Think how to express an error o description or give some details about what happend\n\t\t\t\treturn false;\n\t\t\t} \n\t\t\telse if (actionToDo.action === k.parser.tableAction.SHIFT)\n\t\t\t{\n\t\t\t\tlastItem.symbol = this.currentInput.terminal;\n\t\t\t\tlastItem.currentValue = this.currentInput.string;\n\t\t\t\tlastItem.stringValue = this.currentInput.string;\n\t\t\t\tthis.currentInput = lexer.getNext();\n\t\t\t}\n\t\t\telse if (actionToDo.action === k.parser.tableAction.REDUCE)\n\t\t\t{\n\t\t\t\tlastItem = this._reduce(actionToDo);\n\t\t\t}\n\t\t\telse if (actionToDo.action === k.parser.tableAction.ACCEPT)\n\t\t\t{\n\t\t\t\tlastItem = this._reduce(actionToDo);\n\t\t\t\t//As we extend the grammar adding a extra rule S' => S #, the last stack item has two children and the first one is the expeted result\n\t\t\t\treturn lastItem.AST.nodes[0];\n\t\t\t}\n\n\n\t\t\t//Goto\n\t\t\tstateToGo = this.gotoTable[lastItem.state.getIdentity()][lastItem.symbol];\n\t\t\tif (!stateToGo)\n\t\t\t{\n\t\t\t\treturn false; //The input string is not valid!\n\t\t\t}\n\n\t\t\tthis.stack.push(new k.data.StackItem({\n\t\t\t\tstate: stateToGo\n\t\t\t}));\n\n\t\t\tlastItem = this.stack[this.stack.length-1];\n\n\t\t} while(true);\n\t};\n\n\t/* @function Internal method to apply a reduce action.\n\t* @param {Rule} actionToDo.rule The by which the reduce aciton will take place\n\t* @returns {Object} The last item in the stack already updated */\n\tparser.prototype._reduce = function (actionToDo)\n\t{\n\t\tvar reduceFunctionParameters = {},\n\t\t\tnewASTNode,\n\t\t\tsubASTNodes,\n\t\t\tstackRange,\n\t\t\trule = actionToDo.rule,\n\t\t\tisEMPTYRule = rule.tail.length === 1 && rule.tail[0].name === k.data.specialSymbol.EMPTY,\n\t\t\tlastItem = this.stack[this.stack.length - 1];\n\t\t\t\n\t\tstackRange = isEMPTYRule ? \n\t\t\t\t\t\t//If the reduce rule is the empty one, there is no values to collect\n\t\t\t\t\t\t[] : \n\t\t\t\t\t\t// Get the last n (rule length) elements of the stack ignoring the last one, which is just there for the previous GoTo Action.\n\t\t\t\t\t\tthis.stack.slice(-1 * (rule.tail.length + 1), this.stack.length - 1);\n\t\treduceFunctionParameters.values = k.utils.obj.map(stackRange, function (stackItem)\n\t\t{\n\t\t\treturn stackItem.currentValue || stackItem.symbol;\n\t\t});\n\t\treduceFunctionParameters.rule = rule;\n\n\t\t//Shrink stack based on the reduce rule\n\t\tthis.stack = isEMPTYRule ? \n\t\t\t\t\t\t//Based on the Basic Functionality the last stack item used by the empty rule is already there and no item is require to be removed \n\t\t\t\t\t\tthis.stack :\n\t\t\t\t\t\tthis.stack.slice(0, -1 * rule.tail.length);\n\t\t//Update last stack item\n\t\tlastItem = this.stack[this.stack.length - 1];\n\t\tlastItem.symbol = rule.head;\n\t\tlastItem.currentValue = k.utils.obj.isFunction(rule.reduceFunc) ? rule.reduceFunc.call(this, reduceFunctionParameters) : lastItem.symbol;\n\t\t\n\t\t\n\t\t// Update/Generate AST\n\t\tsubASTNodes = k.utils.obj.map(stackRange, function (stackItem)\n\t\t{\n\t\t\treturn stackItem.AST || stackItem.stringValue;\n\t\t});\n\t\t\n\t\tnewASTNode = new k.data.ASTNode({\n\t\t\tnodes: subASTNodes,\n\t\t\trule: rule,\n\t\t\tsymbol: rule.head,\n\t\t\tstringValue: lastItem.stringValue,\n\t\t\tcurrentValue: lastItem.currentValue\n\t\t});\n\t\tlastItem.AST = newASTNode;\n\n\t\treturn lastItem;\n\t};\n\n\treturn parser;\n})();\n\n\n/* Parser Creator\n* @class\n* @classdesc Util class to simplify the process of creating a parser */\nvar parserCreator = k.parser.parserCreator = (function () {\n\t'use strict';\n\t/*\n\t* Creates an instance of a Parser  Creator. Generally this is not necessary, owing to this class has all its method statics\n\t*\n\t* @constructor\n\t*/\n\tvar creator =  function()\n\t{\n\t};\n\n\t/* @function Helper method to instanciate a new parser and a lexer\n\t* @param {Grammar} options.grammar The grammar used to generate the parser\n\t* @param {AutomataLRGeneratorBase} options.automataGenerator Optional class used to generate the automata. If not specified LR0 will be used\n\t* @param {String} options.strInput Optional String to be processed\n\t* @returns {Object} An object with two properties, parser and lexer */\n\tcreator.create = function (options)\n\t{\n\t\toptions = k.utils.obj.extend({}, {\n\t\t\tautomataGenerator: k.parser.AutomataLALR1Generator\n\t\t}, options || {});\n\t\t\n\t\tvar\tgrammar = options.grammar,\n\t\t\tautomataGenerator = new options.automataGenerator({\n\t\t\t\tgrammar: grammar\n\t\t\t}),\n\t\t\tautomata = automataGenerator.generateAutomata({conflictResolvers: k.parser.ConflictResolver.getDefaultResolvers()}),\n\t\t\tgotoTable = automataGenerator.generateGOTOTable(automata),\n\t\t\tactionTable = automataGenerator.generateACTIONTable(automata, {\n\t\t\t\tconflictResolvers: k.parser.ConflictResolver.getDefaultResolvers(),\n\t\t\t\tignoreErrors: false\n\t\t\t}),\n\t\t\tlexer = new k.lexer.Lexer({\n\t\t\t\tgrammar: grammar,\n\t\t\t\tstream: options.strInput\n\t\t\t}),\n\t\t\tparser = new k.parser.Parser({\n\t\t\t\tgotoTable: gotoTable,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tactionTable: actionTable,\n\t\t\t\tinitialState: automata.initialStateAccessor()\n\t\t\t});\n\n\t\treturn  {\n\t\t\tparser: parser,\n\t\t\tlexer: lexer\n\t\t};\n\t};\n\n\treturn creator;\n})();\n","// See __prologue__.js\n\treturn k;\n});"],"sourceRoot":"/source/"}